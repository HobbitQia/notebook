<!DOCTYPE html>
<html class="no-js" lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="HobbitQia的笔记本" name="description"/>
<link href="https://note.hobbitqia.cc/CSAPP/9/" rel="canonical"/>
<link href="../8/" rel="prev"/>
<link href="../../Logic/" rel="next"/>
<link href="../../log.ico" rel="icon"/>
<meta content="mkdocs-1.6.1, mkdocs-material-9.6.21" name="generator"/>
<title>虚拟内存 - HobbitQia的笔记本</title>
<link href="../../assets/stylesheets/main.2a3383ac.min.css" rel="stylesheet"/>
<link href="../../assets/stylesheets/palette.06af60db.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=LXGW+WenKai+Screen:300,300i,400,400i,700,700i%7CJetBrains+Mono:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"LXGW WenKai Screen";--md-code-font:"JetBrains Mono"}</style>
<link href="../../css/timeline.css" rel="stylesheet"/>
<link href="../../css/heti.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="../../css/custom.css" rel="stylesheet"/>
<link href="../../css/card.css" rel="stylesheet"/>
<link href="../../css/tasklist.css" rel="stylesheet"/>
<link href="../../css/flink.css" rel="stylesheet"/>
<link href="../../css/more_changelog.css" rel="stylesheet"/>
<script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
</head>
<body data-md-color-accent="brown" data-md-color-primary="brown" data-md-color-scheme="default" dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#_1">
          跳转至
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="页眉" class="md-header__inner md-grid">
<a aria-label="HobbitQia的笔记本" class="md-header__button md-logo" data-md-component="logo" href="../.." title="HobbitQia的笔记本">
<img alt="logo" src="../../log.ico"/>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            HobbitQia的笔记本
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              虚拟内存
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Switch to dark mode" class="md-option" data-md-color-accent="brown" data-md-color-media="(prefers-color-scheme: light)" data-md-color-primary="brown" data-md-color-scheme="default" id="__palette_0" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Switch to dark mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"></path></svg>
</label>
<input aria-label="Switch to light mode" class="md-option" data-md-color-accent="indigo" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-primary="indigo" data-md-color-scheme="slate" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_0" hidden="" title="Switch to light mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"></path></svg>
</label>
</form>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="搜索" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="搜索" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"></path></svg>
</label>
<nav aria-label="查找" class="md-search__options">
<button aria-label="清空当前内容" class="md-search__icon md-icon" tabindex="-1" title="清空当前内容" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
</button>
</nav>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="" tabindex="0">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
<ol class="md-search-result__list" role="presentation"></ol>
</div>
</div>
</div>
</div>
</div>
<div class="md-header__source">
<a class="md-source" data-md-component="source" href="https://github.com/HobbitQia/notebook/" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"></path></svg>
</div>
<div class="md-source__repository">
    HobbitQia/notebook
  </div>
</a>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<nav aria-label="标签" class="md-tabs" data-md-component="tabs">
<div class="md-grid">
<ul class="md-tabs__list">
<li class="md-tabs__item">
<a class="md-tabs__link" href="../..">
          
  
  
    
  
  Home

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../ds/">
          
  
  
    
  
  Computer Science

        </a>
</li>
<li class="md-tabs__item md-tabs__item--active">
<a class="md-tabs__link" href="../../ICS/">
          
  
  
    
  
  System

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../DL/">
          
  
  
    
  
  AI

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../EDA/">
          
  
  
    
  
  EDA

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../Mathematics/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%85%A1%28H%29/Rings/">
          
  
  
    
  
  Mathematics

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../Paper/">
          
  
  
    
  
  Papers

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../Misc/">
          
  
  
    
  
  Miscellaneous

        </a>
</li>
</ul>
</div>
</nav>
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="导航栏" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="HobbitQia的笔记本" class="md-nav__button md-logo" data-md-component="logo" href="../.." title="HobbitQia的笔记本">
<img alt="logo" src="../../log.ico"/>
</a>
    HobbitQia的笔记本
  </label>
<div class="md-nav__source">
<a class="md-source" data-md-component="source" href="https://github.com/HobbitQia/notebook/" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"></path></svg>
</div>
<div class="md-source__repository">
    HobbitQia/notebook
  </div>
</a>
</div>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_1" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../..">
<span class="md-ellipsis">
    Home
    
  </span>
</a>
<label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_1_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_1">
<span class="md-nav__icon md-icon"></span>
            Home
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../changelog/">
<span class="md-ellipsis">
    更新记录
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../link/">
<span class="md-ellipsis">
    友链
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
<span class="md-ellipsis">
    Computer Science
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_2_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_2">
<span class="md-nav__icon md-icon"></span>
            Computer Science
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2_1" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../ds/">
<span class="md-ellipsis">
    数据结构与算法
    
  </span>
</a>
<label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_2_1_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_1">
<span class="md-nav__icon md-icon"></span>
            数据结构与算法
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../ds/algorithm/">
<span class="md-ellipsis">
    算法分析
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ds/tree/">
<span class="md-ellipsis">
    树
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ds/heap/">
<span class="md-ellipsis">
    堆
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ds/set/">
<span class="md-ellipsis">
    并查集
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ds/graph/">
<span class="md-ellipsis">
    图论
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ds/sort/">
<span class="md-ellipsis">
    排序
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ds/hash/">
<span class="md-ellipsis">
    散列
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2_2" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../ADS/">
<span class="md-ellipsis">
    高级数据结构与算法分析
    
  </span>
</a>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_2_2_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_2">
<span class="md-nav__icon md-icon"></span>
            高级数据结构与算法分析
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2_3" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../dip/">
<span class="md-ellipsis">
    图像信息处理
    
  </span>
</a>
<label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_2_3_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_3">
<span class="md-nav__icon md-icon"></span>
            图像信息处理
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip1/">
<span class="md-ellipsis">
    图像信息处理介绍
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip2/">
<span class="md-ellipsis">
    二值图像和形态学
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip3/">
<span class="md-ellipsis">
    图像灰度变换与直方图
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip5/">
<span class="md-ellipsis">
    几何变换
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip6/">
<span class="md-ellipsis">
    卷积与滤波
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip7/">
<span class="md-ellipsis">
    双边滤波的加速
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip8/">
<span class="md-ellipsis">
    引导滤波
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip9/">
<span class="md-ellipsis">
    稀疏范数滤波
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip10/">
<span class="md-ellipsis">
    傅里叶变换
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip11/">
<span class="md-ellipsis">
    图像特征检测和提取
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../dip/dip12/">
<span class="md-ellipsis">
    深度学习
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2_4" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../OOP/">
<span class="md-ellipsis">
    面向对象程序设计
    
  </span>
</a>
<label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_2_4_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_4">
<span class="md-nav__icon md-icon"></span>
            面向对象程序设计
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop1/">
<span class="md-ellipsis">
    Introduction
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop2/">
<span class="md-ellipsis">
    Class
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop3/">
<span class="md-ellipsis">
    Container
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop4/">
<span class="md-ellipsis">
    Function
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop5/">
<span class="md-ellipsis">
    Constant and Static
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop6/">
<span class="md-ellipsis">
    Inheritance
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop7/">
<span class="md-ellipsis">
    Polymorphism
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop8/">
<span class="md-ellipsis">
    Copy Ctor
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop9/">
<span class="md-ellipsis">
    Overloaded Operators
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop10/">
<span class="md-ellipsis">
    Templates
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop11/">
<span class="md-ellipsis">
    Exception
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OOP/oop12/">
<span class="md-ellipsis">
    Smart Pointers
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2_5" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../Quan/">
<span class="md-ellipsis">
    量子计算理论与软件系统
    
  </span>
</a>
<label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_2_5_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_5">
<span class="md-nav__icon md-icon"></span>
            量子计算理论与软件系统
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Quan/chap1/">
<span class="md-ellipsis">
    量子态与量子门
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Quan/chap2/">
<span class="md-ellipsis">
    量子测量
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2_6" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../TCS/">
<span class="md-ellipsis">
    计算理论
    
  </span>
</a>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_2_6_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_6">
<span class="md-nav__icon md-icon"></span>
            计算理论
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2_7" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../AOR/">
<span class="md-ellipsis">
    应用运筹学基础
    
  </span>
</a>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_2_7_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_2_7">
<span class="md-nav__icon md-icon"></span>
            应用运筹学基础
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" id="__nav_3" type="checkbox"/>
<label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
<span class="md-ellipsis">
    System
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="true" aria-labelledby="__nav_3_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_3">
<span class="md-nav__icon md-icon"></span>
            System
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3_1" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../ICS/">
<span class="md-ellipsis">
    计算机系统概论
    
  </span>
</a>
<label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_3_1_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_1">
<span class="md-nav__icon md-icon"></span>
            计算机系统概论
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../ICS/ICS-1/">
<span class="md-ellipsis">
    Introduction
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ICS/ICS-2/">
<span class="md-ellipsis">
    Bits, Data Types and Operations
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ICS/ICS-3/">
<span class="md-ellipsis">
    Digital Logic Structures
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ICS/ICS-4/">
<span class="md-ellipsis">
    The von Neumann Model
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ICS/ICS-5/">
<span class="md-ellipsis">
    LC-3
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ICS/ICS-6/">
<span class="md-ellipsis">
    Programming
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ICS/ICS-7/">
<span class="md-ellipsis">
    Assembly Language
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ICS/ICS-8/">
<span class="md-ellipsis">
    Data Structures
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../ICS/ICS-9/">
<span class="md-ellipsis">
    I/0
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" id="__nav_3_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
<span class="md-ellipsis">
    CSAPP
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="true" aria-labelledby="__nav_3_2_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_2">
<span class="md-nav__icon md-icon"></span>
            CSAPP
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../5/">
<span class="md-ellipsis">
    优化程序性能
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../6/">
<span class="md-ellipsis">
    存储器层次结构
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../7/">
<span class="md-ellipsis">
    链接
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../8/">
<span class="md-ellipsis">
    异常控制流
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
<span class="md-ellipsis">
    虚拟内存
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./">
<span class="md-ellipsis">
    虚拟内存
    
  </span>
</a>
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      目录
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
<span class="md-ellipsis">
      地址空间
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_3">
<span class="md-ellipsis">
      虚拟内存
    </span>
</a>
<nav aria-label="虚拟内存" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
<span class="md-ellipsis">
      页表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_5">
<span class="md-ellipsis">
      相关操作
    </span>
</a>
<nav aria-label="相关操作" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_6">
<span class="md-ellipsis">
      页命中
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_7">
<span class="md-ellipsis">
      缺页
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_8">
<span class="md-ellipsis">
      分配页面
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_9">
<span class="md-ellipsis">
      虚拟内存作为内存管理的工具
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_10">
<span class="md-ellipsis">
      虚拟内存作为内存保护的工具
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_11">
<span class="md-ellipsis">
      地址翻译
    </span>
</a>
<nav aria-label="地址翻译" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_12">
<span class="md-ellipsis">
      结合高速缓存和虚拟内存
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#tlb">
<span class="md-ellipsis">
      利用 TLB 加速地址翻译
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_13">
<span class="md-ellipsis">
      多级页表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#intel-core-i7linux">
<span class="md-ellipsis">
      案例分析: Intel Core i7/Linux 内存系统
    </span>
</a>
<nav aria-label="案例分析: Intel Core i7/Linux 内存系统" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#core-i7">
<span class="md-ellipsis">
      Core i7 地址翻译
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#linux">
<span class="md-ellipsis">
      Linux 虚拟内存系统
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#linux_1">
<span class="md-ellipsis">
      Linux 虚拟内存区域
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#linux_2">
<span class="md-ellipsis">
      Linux 缺页异常处理
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_14">
<span class="md-ellipsis">
      内存映射
    </span>
</a>
<nav aria-label="内存映射" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_15">
<span class="md-ellipsis">
      共享对象
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#fork">
<span class="md-ellipsis">
      fork函数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#execve">
<span class="md-ellipsis">
      execve函数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#mmap">
<span class="md-ellipsis">
      mmap函数的用户级内存映射
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_16">
<span class="md-ellipsis">
      动态内存分配
    </span>
</a>
<nav aria-label="动态内存分配" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_17">
<span class="md-ellipsis">
      显式分配器
    </span>
</a>
<nav aria-label="显式分配器" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#mallocfree">
<span class="md-ellipsis">
      malloc和free函数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_18">
<span class="md-ellipsis">
      分配器的要求和目标
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_19">
<span class="md-ellipsis">
      隐式空闲链表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_20">
<span class="md-ellipsis">
      放置已分配的块
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_21">
<span class="md-ellipsis">
      分割内存块
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_22">
<span class="md-ellipsis">
      获取额外的堆内存
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_23">
<span class="md-ellipsis">
      合并空闲块
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_24">
<span class="md-ellipsis">
      实现隐式空闲链表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_30">
<span class="md-ellipsis">
      显式空闲链表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_31">
<span class="md-ellipsis">
      分离的空闲链表
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_35">
<span class="md-ellipsis">
      垃圾收集
    </span>
</a>
<nav aria-label="垃圾收集" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#mark-sweep">
<span class="md-ellipsis">
      Mark &amp; Sweep 垃圾收集器
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#c-mark-sweep">
<span class="md-ellipsis">
      C 程序保守的 Mark &amp; Sweep
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#c">
<span class="md-ellipsis">
      C 程序中常见与内存有关的错误
    </span>
</a>
<nav aria-label="C 程序中常见与内存有关的错误" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_36">
<span class="md-ellipsis">
      间接引用坏指针
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_37">
<span class="md-ellipsis">
      读未初始化的内存
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_38">
<span class="md-ellipsis">
      允许栈缓冲区溢出
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_39">
<span class="md-ellipsis">
      假设指针和他们指向的对象是相同大小
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_40">
<span class="md-ellipsis">
      错位错误
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_41">
<span class="md-ellipsis">
      引用指针而不是它指向的对象
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_42">
<span class="md-ellipsis">
      误解指针运算
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_43">
<span class="md-ellipsis">
      引用不存在的变量
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_44">
<span class="md-ellipsis">
      引用空闲堆块中的数据
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_45">
<span class="md-ellipsis">
      引起内存泄漏
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3_3" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../Logic/">
<span class="md-ellipsis">
    计算机逻辑设计基础
    
  </span>
</a>
<label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_3_3_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_3">
<span class="md-nav__icon md-icon"></span>
            计算机逻辑设计基础
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Logic/logic01/">
<span class="md-ellipsis">
    数字系统和信息
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Logic/logic02/">
<span class="md-ellipsis">
    组合逻辑电路
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Logic/logic03/">
<span class="md-ellipsis">
    组合逻辑电路设计
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Logic/logic04/">
<span class="md-ellipsis">
    时序逻辑电路
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Logic/logic06/">
<span class="md-ellipsis">
    寄存器与寄存器传输
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Logic/logic05/">
<span class="md-ellipsis">
    数字硬件设计
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Logic/logic07/">
<span class="md-ellipsis">
    内存基础
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3_4" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../DB/">
<span class="md-ellipsis">
    数据库系统
    
  </span>
</a>
<label class="md-nav__link" for="__nav_3_4" id="__nav_3_4_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_3_4_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_4">
<span class="md-nav__icon md-icon"></span>
            数据库系统
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db1/">
<span class="md-ellipsis">
    数据库介绍
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db2/">
<span class="md-ellipsis">
    关系模型
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db3/">
<span class="md-ellipsis">
    SQL 语言介绍
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db4/">
<span class="md-ellipsis">
    中级 SQL
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db5/">
<span class="md-ellipsis">
    高级 SQL
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db6/">
<span class="md-ellipsis">
    实体-关系模型
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db7/">
<span class="md-ellipsis">
    关系数据库设计
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db8/">
<span class="md-ellipsis">
    物理存储系统
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db9/">
<span class="md-ellipsis">
    数据存储结构
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db10/">
<span class="md-ellipsis">
    索引
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db11/">
<span class="md-ellipsis">
    查询处理
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db12/">
<span class="md-ellipsis">
    查询优化
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db13/">
<span class="md-ellipsis">
    事务
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db14/">
<span class="md-ellipsis">
    并发控制
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DB/db15/">
<span class="md-ellipsis">
    故障恢复
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3_5" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../CO/">
<span class="md-ellipsis">
    计算机组成与设计
    
  </span>
</a>
<label class="md-nav__link" for="__nav_3_5" id="__nav_3_5_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_3_5_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_5">
<span class="md-nav__icon md-icon"></span>
            计算机组成与设计
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../CO/co1/">
<span class="md-ellipsis">
    计算机概要与技术
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../CO/co3/">
<span class="md-ellipsis">
    计算机的算术运算
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../CO/co2/">
<span class="md-ellipsis">
    指令：计算机的语言
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../CO/co4/">
<span class="md-ellipsis">
    处理器
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../CO/co5/">
<span class="md-ellipsis">
    内存层次架构
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../CO/co6/">
<span class="md-ellipsis">
    存储和 IO
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3_6" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../CA/">
<span class="md-ellipsis">
    计算机体系结构
    
  </span>
</a>
<label class="md-nav__link" for="__nav_3_6" id="__nav_3_6_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_3_6_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_6">
<span class="md-nav__icon md-icon"></span>
            计算机体系结构
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../CA/CA1/">
<span class="md-ellipsis">
    计算机设计基础
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../CA/CA2/">
<span class="md-ellipsis">
    流水线
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../CA/CA3/">
<span class="md-ellipsis">
    内存层次
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../CA/CA4/">
<span class="md-ellipsis">
    指令级并行
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../CA/CA5/">
<span class="md-ellipsis">
    DLP 和 TLP
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3_7" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../OS/">
<span class="md-ellipsis">
    操作系统原理与实践
    
  </span>
</a>
<label class="md-nav__link" for="__nav_3_7" id="__nav_3_7_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_3_7_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_7">
<span class="md-nav__icon md-icon"></span>
            操作系统原理与实践
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap01/">
<span class="md-ellipsis">
    OS 结构
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap02/">
<span class="md-ellipsis">
    进程
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap03/">
<span class="md-ellipsis">
    进程间通信
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap04/">
<span class="md-ellipsis">
    线程
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap05/">
<span class="md-ellipsis">
    调度
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap06/">
<span class="md-ellipsis">
    同步
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap07/">
<span class="md-ellipsis">
    死锁
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap08/">
<span class="md-ellipsis">
    主存
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap09/">
<span class="md-ellipsis">
    虚拟内存
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap10/">
<span class="md-ellipsis">
    大容量存储
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap11/">
<span class="md-ellipsis">
    I/O 系统
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap12/">
<span class="md-ellipsis">
    文件系统接口
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../OS/chap13/">
<span class="md-ellipsis">
    文件系统实现
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3_8" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../Compiler/">
<span class="md-ellipsis">
    编译原理
    
  </span>
</a>
<label class="md-nav__link" for="__nav_3_8" id="__nav_3_8_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_3_8_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_3_8">
<span class="md-nav__icon md-icon"></span>
            编译原理
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Compiler/lec1/">
<span class="md-ellipsis">
    介绍
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Compiler/lec2/">
<span class="md-ellipsis">
    词法分析
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Compiler/lec3/">
<span class="md-ellipsis">
    语法分析
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
<span class="md-ellipsis">
    AI
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_4_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_4">
<span class="md-nav__icon md-icon"></span>
            AI
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_4_1" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../DL/">
<span class="md-ellipsis">
    Deep Learning
    
  </span>
</a>
<label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_4_1_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_1">
<span class="md-nav__icon md-icon"></span>
            Deep Learning
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../DL/lec01/">
<span class="md-ellipsis">
    图像分类
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DL/lec02/">
<span class="md-ellipsis">
    线性分类器
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DL/lec03/">
<span class="md-ellipsis">
    优化
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DL/lec04/">
<span class="md-ellipsis">
    神经网络
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DL/lec05/">
<span class="md-ellipsis">
    反向传播
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DL/lec06/">
<span class="md-ellipsis">
    卷积神经网络
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../DL/lec07/">
<span class="md-ellipsis">
    CNN 架构
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_4_2" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../TinyML/">
<span class="md-ellipsis">
    Efficient ML
    
  </span>
</a>
<label class="md-nav__link" for="__nav_4_2" id="__nav_4_2_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_4_2_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_2">
<span class="md-nav__icon md-icon"></span>
            Efficient ML
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../TinyML/pruning/">
<span class="md-ellipsis">
    剪枝与稀疏性
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../TinyML/quantization/">
<span class="md-ellipsis">
    量化
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../TinyML/llm/">
<span class="md-ellipsis">
    Transformer &amp; LLM
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../TinyML/finetune/">
<span class="md-ellipsis">
    微调和提示工程
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../TinyML/post-training/">
<span class="md-ellipsis">
    训练后 LLM
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_5" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../EDA/">
<span class="md-ellipsis">
    EDA
    
  </span>
</a>
<label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_5_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_5">
<span class="md-nav__icon md-icon"></span>
            EDA
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_5_2" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../EDA/VLSI/">
<span class="md-ellipsis">
    数字集成电路设计
    
  </span>
</a>
<label class="md-nav__link" for="__nav_5_2" id="__nav_5_2_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_5_2_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_5_2">
<span class="md-nav__icon md-icon"></span>
            数字集成电路设计
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../EDA/VLSI/lec01/">
<span class="md-ellipsis">
    介绍
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../EDA/VLSI/lec03/">
<span class="md-ellipsis">
    逻辑综合
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../EDA/VLSI/lec04/">
<span class="md-ellipsis">
    时序分析
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../EDA/VLSI/lec05/">
<span class="md-ellipsis">
    芯片物理设计
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../EDA/VLSI/lec06/">
<span class="md-ellipsis">
    布局
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../EDA/VLSI/lec07/">
<span class="md-ellipsis">
    时钟树综合
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_6" type="checkbox"/>
<label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
<span class="md-ellipsis">
    Mathematics
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_6_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_6">
<span class="md-nav__icon md-icon"></span>
            Mathematics
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_6_1" type="checkbox"/>
<label class="md-nav__link" for="__nav_6_1" id="__nav_6_1_label" tabindex="0">
<span class="md-ellipsis">
    线性代数
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_6_1_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_6_1">
<span class="md-nav__icon md-icon"></span>
            线性代数
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Mathematics/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%85%A1%28H%29/Rings/">
<span class="md-ellipsis">
    线性代数Ⅱ(H)
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_6_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_6_2" id="__nav_6_2_label" tabindex="0">
<span class="md-ellipsis">
    数据建模与分析
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_6_2_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_6_2">
<span class="md-nav__icon md-icon"></span>
            数据建模与分析
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../MLT/report/">
<span class="md-ellipsis">
    读书报告
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../MLT/mlt2/">
<span class="md-ellipsis">
    感知机
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_7" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../Paper/">
<span class="md-ellipsis">
    Papers
    
  </span>
</a>
<label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_7_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_7">
<span class="md-nav__icon md-icon"></span>
            Papers
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_7_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_7_2" id="__nav_7_2_label" tabindex="0">
<span class="md-ellipsis">
    LLM Training
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_7_2_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_7_2">
<span class="md-nav__icon md-icon"></span>
            LLM Training
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/ZeRO/">
<span class="md-ellipsis">
    ZeRO
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/Megatron-LM/">
<span class="md-ellipsis">
    Megatron-LM
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/GPipe/">
<span class="md-ellipsis">
    GPipe
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/mixed_precision/">
<span class="md-ellipsis">
    混合精度训练
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_7_3" type="checkbox"/>
<label class="md-nav__link" for="__nav_7_3" id="__nav_7_3_label" tabindex="0">
<span class="md-ellipsis">
    LLM Inference
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_7_3_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_7_3">
<span class="md-nav__icon md-icon"></span>
            LLM Inference
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/PagedAttention/">
<span class="md-ellipsis">
    PagedAttention &amp; vLLM
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/QServe/">
<span class="md-ellipsis">
    QServe
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_7_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_7_4" id="__nav_7_4_label" tabindex="0">
<span class="md-ellipsis">
    LLM
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_7_4_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_7_4">
<span class="md-nav__icon md-icon"></span>
            LLM
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/GPT-1/">
<span class="md-ellipsis">
    GPT-1
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/GPT-2/">
<span class="md-ellipsis">
    GPT-2
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/GPT-3/">
<span class="md-ellipsis">
    GPT-3
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/LLM2Vec/">
<span class="md-ellipsis">
    LLM2Vec
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_7_5" type="checkbox"/>
<label class="md-nav__link" for="__nav_7_5" id="__nav_7_5_label" tabindex="0">
<span class="md-ellipsis">
    Accelerators
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_7_5_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_7_5">
<span class="md-nav__icon md-icon"></span>
            Accelerators
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/FAST/">
<span class="md-ellipsis">
    FAST
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/softmax/">
<span class="md-ellipsis">
    Softmax 加速
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/NN-LUT/">
<span class="md-ellipsis">
    NN-LUT
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_7_6" type="checkbox"/>
<label class="md-nav__link" for="__nav_7_6" id="__nav_7_6_label" tabindex="0">
<span class="md-ellipsis">
    CGRA
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_7_6_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_7_6">
<span class="md-nav__icon md-icon"></span>
            CGRA
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/VecPAC/">
<span class="md-ellipsis">
    VecPAC
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/APEX/">
<span class="md-ellipsis">
    APEX
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_7_7" type="checkbox"/>
<label class="md-nav__link" for="__nav_7_7" id="__nav_7_7_label" tabindex="0">
<span class="md-ellipsis">
    Diffusion
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_7_7_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_7_7">
<span class="md-nav__icon md-icon"></span>
            Diffusion
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/T2I_RL/">
<span class="md-ellipsis">
    Diffusion + RL
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_7_8" type="checkbox"/>
<label class="md-nav__link" for="__nav_7_8" id="__nav_7_8_label" tabindex="0">
<span class="md-ellipsis">
    Others
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_7_8_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_7_8">
<span class="md-nav__icon md-icon"></span>
            Others
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/BiS-KM/">
<span class="md-ellipsis">
    BiS-KM
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/ChatEDA/">
<span class="md-ellipsis">
    ChatEDA
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Paper/CLIP/">
<span class="md-ellipsis">
    CLIP
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_8" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../../Misc/">
<span class="md-ellipsis">
    Miscellaneous
    
  </span>
</a>
<label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="false" aria-labelledby="__nav_8_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_8">
<span class="md-nav__icon md-icon"></span>
            Miscellaneous
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Misc/float/">
<span class="md-ellipsis">
    浮点数与定点数
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../Misc/fpga/">
<span class="md-ellipsis">
    FPGA Programming
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_8_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_8_4" id="__nav_8_4_label" tabindex="0">
<span class="md-ellipsis">
    LLVM
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_8_4_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_8_4">
<span class="md-nav__icon md-icon"></span>
            LLVM
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Misc/LLVM/ir/">
<span class="md-ellipsis">
    LLVM IR
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_8_5" type="checkbox"/>
<label class="md-nav__link" for="__nav_8_5" id="__nav_8_5_label" tabindex="0">
<span class="md-ellipsis">
    CGRA
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_8_5_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_8_5">
<span class="md-nav__icon md-icon"></span>
            CGRA
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Misc/CGRA/intro/">
<span class="md-ellipsis">
    CGRA 介绍
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_8_6" type="checkbox"/>
<label class="md-nav__link" for="__nav_8_6" id="__nav_8_6_label" tabindex="0">
<span class="md-ellipsis">
    PIM
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_8_6_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_8_6">
<span class="md-nav__icon md-icon"></span>
            PIM
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../Misc/PIM/upmem/">
<span class="md-ellipsis">
    PIM 架构介绍
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_8_7" type="checkbox"/>
<label class="md-nav__link" for="__nav_8_7" id="__nav_8_7_label" tabindex="0">
<span class="md-ellipsis">
    Android
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_8_7_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_8_7">
<span class="md-nav__icon md-icon"></span>
            Android
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../android/dataflow/">
<span class="md-ellipsis">
    触控事件的数据流
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      目录
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
<span class="md-ellipsis">
      地址空间
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_3">
<span class="md-ellipsis">
      虚拟内存
    </span>
</a>
<nav aria-label="虚拟内存" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
<span class="md-ellipsis">
      页表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_5">
<span class="md-ellipsis">
      相关操作
    </span>
</a>
<nav aria-label="相关操作" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_6">
<span class="md-ellipsis">
      页命中
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_7">
<span class="md-ellipsis">
      缺页
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_8">
<span class="md-ellipsis">
      分配页面
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_9">
<span class="md-ellipsis">
      虚拟内存作为内存管理的工具
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_10">
<span class="md-ellipsis">
      虚拟内存作为内存保护的工具
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_11">
<span class="md-ellipsis">
      地址翻译
    </span>
</a>
<nav aria-label="地址翻译" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_12">
<span class="md-ellipsis">
      结合高速缓存和虚拟内存
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#tlb">
<span class="md-ellipsis">
      利用 TLB 加速地址翻译
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_13">
<span class="md-ellipsis">
      多级页表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#intel-core-i7linux">
<span class="md-ellipsis">
      案例分析: Intel Core i7/Linux 内存系统
    </span>
</a>
<nav aria-label="案例分析: Intel Core i7/Linux 内存系统" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#core-i7">
<span class="md-ellipsis">
      Core i7 地址翻译
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#linux">
<span class="md-ellipsis">
      Linux 虚拟内存系统
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#linux_1">
<span class="md-ellipsis">
      Linux 虚拟内存区域
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#linux_2">
<span class="md-ellipsis">
      Linux 缺页异常处理
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_14">
<span class="md-ellipsis">
      内存映射
    </span>
</a>
<nav aria-label="内存映射" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_15">
<span class="md-ellipsis">
      共享对象
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#fork">
<span class="md-ellipsis">
      fork函数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#execve">
<span class="md-ellipsis">
      execve函数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#mmap">
<span class="md-ellipsis">
      mmap函数的用户级内存映射
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_16">
<span class="md-ellipsis">
      动态内存分配
    </span>
</a>
<nav aria-label="动态内存分配" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_17">
<span class="md-ellipsis">
      显式分配器
    </span>
</a>
<nav aria-label="显式分配器" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#mallocfree">
<span class="md-ellipsis">
      malloc和free函数
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_18">
<span class="md-ellipsis">
      分配器的要求和目标
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_19">
<span class="md-ellipsis">
      隐式空闲链表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_20">
<span class="md-ellipsis">
      放置已分配的块
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_21">
<span class="md-ellipsis">
      分割内存块
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_22">
<span class="md-ellipsis">
      获取额外的堆内存
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_23">
<span class="md-ellipsis">
      合并空闲块
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_24">
<span class="md-ellipsis">
      实现隐式空闲链表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_30">
<span class="md-ellipsis">
      显式空闲链表
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_31">
<span class="md-ellipsis">
      分离的空闲链表
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_35">
<span class="md-ellipsis">
      垃圾收集
    </span>
</a>
<nav aria-label="垃圾收集" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#mark-sweep">
<span class="md-ellipsis">
      Mark &amp; Sweep 垃圾收集器
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#c-mark-sweep">
<span class="md-ellipsis">
      C 程序保守的 Mark &amp; Sweep
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#c">
<span class="md-ellipsis">
      C 程序中常见与内存有关的错误
    </span>
</a>
<nav aria-label="C 程序中常见与内存有关的错误" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_36">
<span class="md-ellipsis">
      间接引用坏指针
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_37">
<span class="md-ellipsis">
      读未初始化的内存
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_38">
<span class="md-ellipsis">
      允许栈缓冲区溢出
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_39">
<span class="md-ellipsis">
      假设指针和他们指向的对象是相同大小
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_40">
<span class="md-ellipsis">
      错位错误
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_41">
<span class="md-ellipsis">
      引用指针而不是它指向的对象
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_42">
<span class="md-ellipsis">
      误解指针运算
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_43">
<span class="md-ellipsis">
      引用不存在的变量
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_44">
<span class="md-ellipsis">
      引用空闲堆块中的数据
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_45">
<span class="md-ellipsis">
      引起内存泄漏
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1 id="_1"><strong>虚拟内存</strong><a class="headerlink" href="#_1" title="Permanent link">¶</a></h1>
<div style="margin-top: -30px; font-size: 0.75em; opacity: 0.7;">
<p><span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8zm6.78 1a.7.7 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38z"></path></svg></span> 约<span class="heti-skip"><span class="heti-spacing"> </span>14714<span class="heti-spacing"> </span></span>个字 <span class="twemoji"><svg viewbox="0 0 576 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M360.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6m64.6 136.1c-12.5 12.5-12.5 32.8 0 45.3l73.4 73.4-73.4 73.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l96-96c12.5-12.5 12.5-32.8 0-45.3l-96-96c-12.5-12.5-32.8-12.5-45.3 0zm-274.7 0c-12.5-12.5-32.8-12.5-45.3 0l-96 96c-12.5 12.5-12.5 32.8 0 45.3l96 96c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l73.3-73.4c12.5-12.5 12.5-32.8 0-45.3z"></path></svg></span> <span>76<span class="heti-spacing"> </span></span>行代码 <span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 17H7V3h14m0-2H7a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2M3 5H1v16a2 2 0 0 0 2 2h16v-2H3m12.96-10.71-2.75 3.54-1.96-2.36L8.5 15h11z"></path></svg></span> <span>49<span class="heti-spacing"> </span></span>张图片 <span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 20c4.42 0 8-3.58 8-8s-3.58-8-8-8-8 3.58-8 8 3.58 8 8 8m0-18c5.5 0 10 4.5 10 10s-4.5 10-10 10C6.47 22 2 17.5 2 12S6.5 2 12 2m.5 11H11V7h1.5v4.26l3.7-2.13.75 1.3z"></path></svg></span> 预计阅读时间<span class="heti-skip"><span class="heti-spacing"> </span>50<span class="heti-spacing"> </span></span>分钟</p>
</div>
<p>现代系统提供了一种对主存的抽象<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>称为<strong>虚拟内存<span><span class="heti-spacing"> </span>(VM)</span></strong>.  </p>
<ul>
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>在主存中只保存活动区域<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>并根据需要在磁盘和主存之间来回传送数据<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>以此高效使用主存<span><span class="heti-spacing"> </span>.</span> </li>
<li>它为每个进程提供了一致的地址空间<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>从而简化了内存管理<span><span class="heti-spacing"> </span>.</span> </li>
<li>它保护了每个进程的地址空间不被其他进程破坏<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<h2 id="_2"><strong>地址空间</strong><a class="headerlink" href="#_2" title="Permanent link">¶</a></h2>
<p><strong>地址空间<span><span class="heti-spacing"> </span>(address space)</span></strong> 是一个非负整数地址的有序集合<span><span class="heti-spacing"> </span>. <span class="arithmatex">\(\{0,1,2,\ldots\}\)</span></span><br/>
如果地址空间中的整数是连续的, 我们称为<strong>线性地址空间</strong><span>.(<span class="heti-spacing"> </span></span>假设我们讨论的都是线性地址空间<span><span class="heti-spacing"> </span>)</span> </p>
<p>计算机系统的主存被组织成一个由<span class="heti-skip"><span class="heti-spacing"> </span>M<span class="heti-spacing"> </span></span>个字节大小的单元组成的数组，<strong>每个字节</strong>都有一个唯一的<strong>物理地址<span><span class="heti-spacing"> </span>(Physical Address)</span></strong><span>,<span class="heti-spacing"> </span></span>并且物理地址是连续的。由此就构成了一个<strong>物理地址空间<span><span class="heti-spacing"> </span>(Physical Address Space)</span></strong><span>,<span class="heti-spacing"> </span></span>对应于系统中物理内存的<span class="heti-skip"><span class="heti-spacing"> </span>M<span class="heti-spacing"> </span></span>个字节<span class="heti-skip"><span class="heti-spacing"> </span>. CPU<span class="heti-spacing"> </span></span>可以通过物理地址来访问内存，这种方式称为<strong>物理寻址<span><span class="heti-spacing"> </span>(Physical Addressing)</span></strong><span>,<span class="heti-spacing"> </span></span>再将获得的数据字保存到寄存器中<span><span class="heti-spacing"> </span>.</span> </p>
<p><img alt="" src="https://pic4.zhimg.com/80/v2-e9e4cec80db6537cca1d9a152e26a0e7_1440w.jpg"/></p>
<p>对于主存存储器资源也可以通过虚拟内存提供另一种不同的视图<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>现代<span class="heti-skip"><span class="heti-spacing"> </span>CPU<span class="heti-spacing"> </span></span>从一个有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(N=2^n\)</span><span class="heti-spacing"> </span></span>个地址的地址空间中生成<strong>虚拟地址<span><span class="heti-spacing"> </span>(Virtual Address)</span></strong><span>,<span class="heti-spacing"> </span></span>该地址空间称为<strong>虚拟地址空间<span><span class="heti-spacing"> </span>(Virtual Address Space)</span></strong><span>,<span class="heti-spacing"> </span></span>虚拟地址空间的大小由表示最大虚拟地址所需的位数<span class="heti-skip"><span class="heti-spacing"> </span>n<span class="heti-spacing"> </span></span>来确定<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>现代系统支持<span class="heti-skip"><span class="heti-spacing"> </span>32<span class="heti-spacing"> </span></span>位或<span class="heti-skip"><span class="heti-spacing"> </span>64<span class="heti-spacing"> </span></span>位的虚拟地址空间<span class="heti-skip"><span class="heti-spacing"> </span>. CPU<span class="heti-spacing"> </span></span>会使用虚拟地址来访问主存，称为<strong>虚拟寻址<span><span class="heti-spacing"> </span>(Virtual Addressing)</span></strong><span>,<span class="heti-spacing"> </span></span>需要首先通过<strong>地址翻译<span><span class="heti-spacing"> </span>(Address Translation)</span></strong> 将虚拟地址转换为对应的物理地址<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>再通过物理地址来访问内存<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而地址翻译类似于异常处理<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>软硬结合<span><span class="heti-spacing"> </span>)</span>，需要<span class="heti-skip"><span class="heti-spacing"> </span>CPU<span class="heti-spacing"> </span></span>上的<strong>内存管理单元<span><span class="heti-spacing"> </span>(Memory Management Unit, MMU)</span></strong><span>,<span class="heti-spacing"> </span></span>以及内存中由操作系统管理的查询表来动态翻译虚拟内存<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>所以通过<span class="heti-skip"><span class="heti-spacing"> </span>MMU<span class="heti-spacing"> </span></span>来控制对内存的读写<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>达到对内存进行虚拟化的目的<span><span class="heti-spacing"> </span>.</span> </p>
<p><img alt="" src="https://pic4.zhimg.com/80/v2-fe54138c5ecb9ee75396ab31c7dea87b_1440w.jpg"/></p>
<div class="admonition info">
<p class="admonition-title">为什么要使用<span class="heti-skip"><span class="heti-spacing"> </span>MME<span class="heti-spacing"> </span></span>来对内存进行抽象</p>
<ul>
<li>虚拟内存将<span class="heti-skip"><span class="heti-spacing"> </span>DRAM<span class="heti-spacing"> </span></span>内存作为磁盘上实际数据的高速缓存，即我们可以在主存访问磁盘大小的空间，而主存只保存活动区域，根据需要在磁盘和主存之间来回传送数据，使得进程可以得到更大的地址空间，并且更有效地利用主存资源<span><span class="heti-spacing"> </span>.</span> </li>
<li>虚拟内存为每个进程提供一致的虚拟地址空间，代码和数据总是加载到固定的地址，堆栈位于用户课件地址空间的顶部等等，但是实际上与那些虚拟地址相对应的内容分布在整个主存储器中，所以通过使用虚拟内存可以简化内存的管理<span><span class="heti-spacing"> </span>.</span> </li>
<li>虚拟内存保护每个进程的地址空间不会被别的进程破坏<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
</div>
<h2 id="_3"><strong>虚拟内存</strong><a class="headerlink" href="#_3" title="Permanent link">¶</a></h2>
<p>概念上<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>虚拟内存被组织为一个由存放在磁盘上的<span class="heti-skip"><span class="heti-spacing"> </span>N<span class="heti-spacing"> </span></span>个连续字节大小的单元组成的数组<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>每个字节有一个唯一的虚拟地址<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>而该数组的内容被缓存到主存中<span><span class="heti-spacing"> </span>.</span> </p>
<p><span>VM<span class="heti-spacing"> </span></span>系统将虚拟内存分割为<strong>虚拟页<span><span class="heti-spacing"> </span>(Virtual Page, VP)</span></strong><span>,<span class="heti-spacing"> </span></span>每个虚拟页的大小为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P=2^p\)</span><span class="heti-spacing"> </span></span>字节<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>类似地物理内存被分割为<strong>物理页<span><span class="heti-spacing"> </span>(Physical Page, PP)</span></strong><span>,<span class="heti-spacing"> </span></span>大小也为<span class="heti-skip"><span class="heti-spacing"> </span>P<span class="heti-spacing"> </span></span>字节<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>物理页也被称为<strong>页帧<span><span class="heti-spacing"> </span>(page frame)</span></strong>.  </p>
<p>虚拟页面分为三个不相交的子集<span><span class="heti-spacing"> </span>:</span><br/>
(这里的物理内存即主存, 相当于 DRAM 缓存)</p>
<ul>
<li><strong>未分配的</strong><span>: VM<span class="heti-spacing"> </span></span>系统还未分配<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>或者创建<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>的页<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>不占用任何磁盘空间  </li>
<li><strong>缓存的</strong><span>:<span class="heti-spacing"> </span></span>当前已缓存在物理内存中的已分配页  </li>
<li><strong>未缓存的</strong><span>:<span class="heti-spacing"> </span></span>未缓存在物理内存中的已分配页   </li>
</ul>
<p><img alt="" src="https://pic1.zhimg.com/80/v2-5d4615fb2e1f516189050500cf1b0130_1440w.jpg"/></p>
<p><span>DRAM<span class="heti-spacing"> </span></span>缓存的不命中代价更昂贵<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>而且从磁盘的一个扇区读第一个字节的时间开销也非常大<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>因此虚拟页往往很大<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>通常是<span class="heti-skip"><span class="heti-spacing"> </span>4KB~2MB. DRAM<span class="heti-spacing"> </span></span>缓存是全相联的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>任何虚拟页可以放在任何物理页中<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>因为对磁盘访问时间长<span class="heti-skip"><span class="heti-spacing"> </span>, DRAM<span class="heti-spacing"> </span></span>缓存总是采用写回<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>而不是直写<span><span class="heti-spacing"> </span>.</span> </p>
<h3 id="_4"><strong>页表</strong><a class="headerlink" href="#_4" title="Permanent link">¶</a></h3>
<p>为了判断虚拟页是否缓存在<span class="heti-skip"><span class="heti-spacing"> </span>DRAM<span class="heti-spacing"> </span></span>中的某个地方<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>软硬件联合<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>包括操作系统软件<span class="heti-skip"><span class="heti-spacing"> </span>, MMU<span class="heti-spacing"> </span></span>中的地址翻译硬件和一个存放在物理内存中的<strong>页表</strong><span>)<span class="heti-spacing"> </span></span>提供了这个功能<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>页表将虚拟页映射到物理页<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>每次地址翻译硬件将一个虚拟地址转为物理地址时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>都会读取页表<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>操作系统负责维护页表的内容<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>以及在磁盘和<span class="heti-skip"><span class="heti-spacing"> </span>DRAM<span class="heti-spacing"> </span></span>之间来回传送页<span><span class="heti-spacing"> </span>.</span> </p>
<p><strong>页表</strong>就是一个<strong>页表条目<span><span class="heti-spacing"> </span>(Page Table Entry, PTE)</span></strong> 的数组<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>虚拟地址空间中每个页在页表中一个固定偏移量处都有一个<span class="heti-skip"><span class="heti-spacing"> </span>PTE.<span class="heti-spacing"> </span></span>我们假设<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>是一个<strong>有效位</strong>和一个<span class="heti-skip"><span class="heti-spacing"> </span>n<span class="heti-spacing"> </span></span>位地址字段组成<span><span class="heti-spacing"> </span>.</span> </p>
<ul>
<li>有效位表明该虚拟页是否被缓存在<span class="heti-skip"><span class="heti-spacing"> </span>DRAM<span class="heti-spacing"> </span></span>中<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如果设置了有效位<span class="heti-skip"><span class="heti-spacing"> </span>, n<span class="heti-spacing"> </span></span>位地址字段就表示<span class="heti-skip"><span class="heti-spacing"> </span>DRAM<span class="heti-spacing"> </span></span>中相应物理页的起始地址<span><span class="heti-spacing"> </span>.</span> </li>
<li>没有设置有效位<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>如果未分配则以一个空地址表示<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>如果已经分配<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>地址字段就是虚拟内存<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>磁盘<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>中虚拟页的起始地址<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<p><strong>注</strong><span>:<span class="heti-spacing"> </span></span>因为<span class="heti-skip"><span class="heti-spacing"> </span>DRAM<span class="heti-spacing"> </span></span>缓存是全相联的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>所以任意物理页都可以包含任意虚拟页<span><span class="heti-spacing"> </span>.</span> </p>
<p><img alt="" src="https://pic3.zhimg.com/80/v2-e9e1bac3a188b7d79c5d295e95fbef96_1440w.jpg"/></p>
<h3 id="_5"><strong>相关操作</strong><a class="headerlink" href="#_5" title="Permanent link">¶</a></h3>
<p>在磁盘和内存之间传送页的活动叫做<strong>交换</strong>或者<strong>页面调度<span><span class="heti-spacing"> </span>(paging)</span></strong><span>.<span class="heti-spacing"> </span></span>页从磁盘换入<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>或者<em>页面调入</em><span>) DRAM<span class="heti-spacing"> </span></span>和从<span class="heti-skip"><span class="heti-spacing"> </span>DRAM<span class="heti-spacing"> </span></span>换出<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>或者<em>页面调出</em><span>)<span class="heti-spacing"> </span></span>磁盘<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>所有现代系统都使用<strong>按需页面调度<span><span class="heti-spacing"> </span>(demand paging)</span></strong> 的方式<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>即当有不命中发生时猜换入页面<span><span class="heti-spacing"> </span>.</span> </p>
<div class="admonition info">
<p class="admonition-title">又是局部性救了我们</p>
<p>虚拟内存之所以有效，也是因为局部性<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>虚拟内存作为下一层存储器层次，大小会比物理内存大，所以运行过程中程序引用的不同页面总数可能会超出物理内存大小<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如果程序具有好的局部性，则在任意时刻的工作集较小，程序会趋于在一个较小的<strong>活动页面<span><span class="heti-spacing"> </span>(Active Page)</span></strong> 集合上工作，所以只需要在一开始将工作集页面调度到物理内存中，过后就不会产生额外的磁盘流量了<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>但是如果局部性较差，则工作集超过了物理内存大小，则会发生<strong>抖动<span><span class="heti-spacing"> </span>(Thrashing)</span></strong>，使得不断从磁盘中读取页到物理内存中，程序性能大大降低<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span>Linux<span class="heti-spacing"> </span></span>中，可以通过<code>getrusage</code>函数检测缺页的数量<span><span class="heti-spacing"> </span>.</span> </p>
</div>
<h4 id="_6"><strong>页命中</strong><a class="headerlink" href="#_6" title="Permanent link">¶</a></h4>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span>CPU<span class="heti-spacing"> </span></span>想要访问位于虚拟地址<span class="heti-skip"><span class="heti-spacing"> </span>x<span class="heti-spacing"> </span></span>中的数据字时，会首先通过地址翻译硬件将虚拟地址作为一个索引来定位<span><span class="heti-spacing"> </span>PTE</span> ，然后通过<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>来确定对应的虚拟页的状态。如果<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>的有效位为<span><span class="heti-spacing"> </span>1</span>，说明该虚拟页被缓存在物理内存了，则<span class="heti-skip"><span class="heti-spacing"> </span>CPU<span class="heti-spacing"> </span></span>可以通过该<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>的地址字段获得物理内存的地址，然后进行访问<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这就是<strong>页命中</strong>.  </p>
<p><strong><em>e.g.</em></strong> 上图中假设我们访问<span class="heti-skip"><span class="heti-spacing"> </span>VP2,<span class="heti-spacing"> </span></span>即为一个页命中<span><span class="heti-spacing"> </span>.</span> </p>
<h4 id="_7"><strong>缺页</strong><a class="headerlink" href="#_7" title="Permanent link">¶</a></h4>
<p><span>DRAM<span class="heti-spacing"> </span></span>缓存不命中称为<strong>缺页<span><span class="heti-spacing"> </span>(page fault)</span></strong><span>.<span class="heti-spacing"> </span></span>如上图中我们访问<span class="heti-skip"><span class="heti-spacing"> </span>VP3,<span class="heti-spacing"> </span></span>但从有效位我们可以推断处<span class="heti-skip"><span class="heti-spacing"> </span>VP3<span class="heti-spacing"> </span></span>并未被缓存到<span class="heti-skip"><span class="heti-spacing"> </span>DRAM<span class="heti-spacing"> </span></span>中<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>因此触发一个<strong>缺页异常</strong><span>,<span class="heti-spacing"> </span></span>随后异常处理程序选择一个牺牲页进行替换<span><span class="heti-spacing"> </span>.</span> </p>
<div class="admonition example">
<p class="admonition-title">Example</p>
<p><img alt="" src="https://pic1.zhimg.com/80/v2-b4548b464eb1fac54739d005a319cd50_1440w.jpg"/></p>
<p>在这个例子中<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>我们选择了<span class="heti-skip"><span class="heti-spacing"> </span>VP4<span class="heti-spacing"> </span></span>作为牺牲页<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>如果<span class="heti-skip"><span class="heti-spacing"> </span>VP4<span class="heti-spacing"> </span></span>已经被修改了内核会把它写回磁盘<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>写回<span class="heti-skip"><span class="heti-spacing"> </span>).<span class="heti-spacing"> </span></span>随后内核从磁盘复制<span class="heti-skip"><span class="heti-spacing"> </span>VP3<span class="heti-spacing"> </span></span>到内存中的<span class="heti-skip"><span class="heti-spacing"> </span>PP3,<span class="heti-spacing"> </span></span>更新<span class="heti-skip"><span class="heti-spacing"> </span>PTE3,<span class="heti-spacing"> </span></span>随后返回<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>异常程序返回后<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>重新启动导致缺页的指令<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>该指令重新发送虚拟地址到地址翻译硬件<span><span class="heti-spacing"> </span>.</span> </p>
</div>
<h4 id="_8"><strong>分配页面</strong><a class="headerlink" href="#_8" title="Permanent link">¶</a></h4>
<div class="admonition example">
<p class="admonition-title">Example</p>
<p><img alt="20220903222523" src="https://s2.loli.net/2022/09/03/d8mCWe1yctBUEZv.png"/><br/>
如图中, 我们调用 malloc, VP5 的分配过程是在磁盘上创造空间并更新 PTE5.  </p>
</div>
<h3 id="_9"><strong>虚拟内存作为内存管理的工具</strong><a class="headerlink" href="#_9" title="Permanent link">¶</a></h3>
<p>操作系统为每个进程提供了一个独立的页表<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>即一个独立的虚拟地址空间<span><span class="heti-spacing"> </span>.</span><br/>
<strong>注<span class="heti-skip"><span class="heti-spacing"> </span>:<span class="heti-spacing"> </span></span>多个虚拟页面可以映射到同一个共享物理页面<span><span class="heti-spacing"> </span>.</span></strong> </p>
<p><img alt="" src="https://pic1.zhimg.com/80/v2-d757739487172cd17091dd6f40b3eba8_1440w.jpg"/></p>
<ul>
<li>
<p><strong>简化链接</strong><span>:<span class="heti-spacing"> </span></span>独立的地址空间允许每个进程的内存映像使用相同的基本格式<span><span class="heti-spacing"> </span>.</span><br/>
如
<img alt="" src="https://pic1.zhimg.com/80/v2-99ae53e2dd031bf86a62181e0d885708_1440w.jpg"/>
对于 64 位地址空间, 代码段总是从虚拟地址 0x400000 开始, 数据段跟在代码段之后, 中间一段对其空白. 栈占据用户进程地址空间最高的部分, 并向下生长.  </p>
</li>
<li>
<p><strong>简化加载</strong><span>:<span class="heti-spacing"> </span></span>要把可执行文件中<code>.text</code>和<code>.data</code>节加载到一个新创建的进程中<span class="heti-skip"><span class="heti-spacing"> </span>, Linux<span class="heti-spacing"> </span></span>加载器为其分配虚拟页<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>把它们标记为无效<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>即未被缓存<span class="heti-skip"><span class="heti-spacing"> </span>),<span class="heti-spacing"> </span></span>将<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>指向目标文件中适当的位置<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>访问某一虚拟地址时，发现其对应的<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>是无效的，则会发起缺页异常，通过缺页异常处理程序自动地将虚拟页加载到物理页中<span><span class="heti-spacing"> </span>.</span><br/>
<strong>加载器从不从磁盘到内存实际复制任何数据<span><span class="heti-spacing"> </span>.</span></strong><span>(<span class="heti-spacing"> </span></span>程序运行中可能会<span><span class="heti-spacing"> </span>)</span> </p>
</li>
<li><strong>简化共享</strong><span>:<span class="heti-spacing"> </span></span>这里只需要在进程中通过一个<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>指向该共享的数据或代码的物理页，就能实现在所有进程中共享的结果<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>简化内存分配</strong><span>:<span class="heti-spacing"> </span></span>当一个运行在用户进程的程序要求额外的堆空间<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>如调用<code>malloc</code>时<span class="heti-skip"><span class="heti-spacing"> </span>),<span class="heti-spacing"> </span></span>操作系统要分配一个适当数字个连续的虚拟内存页面<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>并将它们映射到物理内存中任意<span class="heti-skip"><span class="heti-spacing"> </span>k<span class="heti-spacing"> </span></span>个物理页面<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>由于页面映射<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>操作系统分配的物理页面可以随机分配在物理内存中<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<h3 id="_10"><strong>虚拟内存作为内存保护的工具</strong><a class="headerlink" href="#_10" title="Permanent link">¶</a></h3>
<p>我们可以在<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>上添加一些额外的许可位来限制对一个虚拟页面的访问<span><span class="heti-spacing"> </span>.</span> </p>
<p><img alt="" src="https://pic2.zhimg.com/80/v2-9cff7dde2a492e8e895cc6365cfb24d1_1440w.jpg"/></p>
<p>这里引入了三个字段<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><strong>SUP</strong><span>:<span class="heti-spacing"> </span></span>确定该物理页的访问权限<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>确定是否需要内核模式才能访问</li>
<li><strong>READ</strong><span>:<span class="heti-spacing"> </span></span>确定该物理页的读权限</li>
<li><strong>WRITE</strong><span>:<span class="heti-spacing"> </span></span>确定该物理页的写权限</li>
</ul>
<p>如果一条指令违反了许可条件<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>那么<span class="heti-skip"><span class="heti-spacing"> </span>CPU<span class="heti-spacing"> </span></span>触发一个一般保护保障<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>将控制传递给一个内核中的异常处理程序<span class="heti-skip"><span class="heti-spacing"> </span>. Linux shell<span class="heti-spacing"> </span></span>将这种异常报告称为<strong>段错误<span><span class="heti-spacing"> </span>(segment fault)</span></strong>.  </p>
<h2 id="_11"><strong>地址翻译</strong><a class="headerlink" href="#_11" title="Permanent link">¶</a></h2>
<div align="center"> <img src="https://s2.loli.net/2022/09/04/JoNxBVFewDgOpr6.png" width="70%/"/> </div>
<p>形式上说<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>地址翻译就是一个<span class="heti-skip"><span class="heti-spacing"> </span>N<span class="heti-spacing"> </span></span>元素的虚拟地址空间<span class="heti-skip"><span class="heti-spacing"> </span>(VAS)<span class="heti-spacing"> </span></span>中的元素和一个<span class="heti-skip"><span class="heti-spacing"> </span>M<span class="heti-spacing"> </span></span>元素的物理地址空间<span class="heti-skip"><span class="heti-spacing"> </span>(PAS)<span class="heti-spacing"> </span></span>中元素的一个映射<span><span class="heti-spacing"> </span>: <span class="arithmatex">\(MAP:VAS\rightarrow PAS \cup\empty\)</span></span><br/>
<img alt="" src="https://pic1.zhimg.com/80/v2-5241363e3a33c7cd7b35e60a332cd840_1440w.png"/></p>
<p><img alt="" src="https://pic2.zhimg.com/80/v2-a64b4da73ce4e4dc0a40f52f0bade5d9_1440w.jpg"/></p>
<ul>
<li><strong>地址翻译</strong><span>:<span class="heti-spacing"> </span></span>虚拟页大小为<span class="heti-skip"><span class="heti-spacing"> </span>P<span class="heti-spacing"> </span></span>个字节，所以需要虚拟地址的低<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>位来索引一个虚拟页中的字节<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>得到<strong>虚拟页偏移量<span><span class="heti-spacing"> </span>Virtual Page Offset</span>，VPO)</strong><span>,<span class="heti-spacing"> </span></span>然后通过虚拟地址的高<span class="heti-skip"><span class="heti-spacing"> </span>n-p<span class="heti-spacing"> </span></span>位来确定虚拟页在页表中的索引<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>得到<strong>虚拟页号<span><span class="heti-spacing"> </span>(Virtual Page Number</span>，VPN)</strong>.<br/>
而页表的起始地址保存在一个特殊的 CPU 寄存器 <strong>页表基址寄存器<span><span class="heti-spacing"> </span>(Page Table Base Register</span>，PTBR)</strong> 中，所以可以通过<span class="heti-skip"><span class="heti-spacing"> </span>VPN<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>PTBR<span class="heti-spacing"> </span></span>组合得到想要的<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>的物理内存地址<span><span class="heti-spacing"> </span>.</span><br/>
并且由于虚拟页和物理页的大小相同, 所以两者编码页中偏移量所需的位数 p 相同, 可以假设数据在虚拟页和在物理页中的偏移量相同, 由此就无需在页表中保存<strong>物理页偏移量<span><span class="heti-spacing"> </span>(Physical Page Offset</span>，PPO)</strong><span>,<span class="heti-spacing"> </span></span>只需要保存<strong>物理页号<span><span class="heti-spacing"> </span>(Physical Page Number</span>，PPN)</strong><span>,<span class="heti-spacing"> </span></span>可以直接将<span class="heti-skip"><span class="heti-spacing"> </span>VPO<span class="heti-spacing"> </span></span>复制给<span class="heti-skip"><span class="heti-spacing"> </span>PPO,<span class="heti-spacing"> </span></span>来确定数据在物理页中的偏移量<span><span class="heti-spacing"> </span>.</span><br/>
<strong>注<span><span class="heti-spacing"> </span>:</span></strong> 从缓存角度看<span class="heti-skip"><span class="heti-spacing"> </span>, VPN<span class="heti-spacing"> </span></span>就是标志位<span class="heti-skip"><span class="heti-spacing"> </span>, VPO<span class="heti-spacing"> </span></span>就是块偏移<span><span class="heti-spacing"> </span>.</span> <strong>页表中只保存<span class="heti-skip"><span class="heti-spacing"> </span>PPN<span class="heti-spacing"> </span></span>和标志位</strong>.  </li>
<li>
<p>页面命中主要执行以下步骤<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li>处理器生成一个虚拟地址<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>并传给<span><span class="heti-spacing"> </span>MMU</span></li>
<li><span>MMU<span class="heti-spacing"> </span></span>生成<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>地址<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>因为页表保存在物理内存中<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这里发送的<span class="heti-skip"><span class="heti-spacing"> </span>PTEA<span class="heti-spacing"> </span></span>即<code>PTBR+VPN</code><span class="heti-skip"><span class="heti-spacing"> </span>),<span class="heti-spacing"> </span></span>并从高速缓存<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>主存请求得到它</li>
<li>高速缓存<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>主存向<span class="heti-skip"><span class="heti-spacing"> </span>MMU<span class="heti-spacing"> </span></span>返回<span class="heti-skip"><span class="heti-spacing"> </span>PTE(<span class="heti-spacing"> </span></span>不包含<span><span class="heti-spacing"> </span>PPO)</span> </li>
<li><span>MMU<span class="heti-spacing"> </span></span>构造物理地址<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>并把它传送给高速缓存<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>主存  </li>
<li>高速缓存<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>主存返回所请求的数据字给处理器  </li>
</ul>
<p><img alt="" src="https://pic2.zhimg.com/80/v2-aa3d40da93fb182643cd2d3ecea1edf9_1440w.jpg"/>
* 页面不命中主要执行以下步骤:  </p>
<ul>
<li>前三步与页面命中相同  </li>
<li><span>PTE<span class="heti-spacing"> </span></span>中有效位是<span class="heti-skip"><span class="heti-spacing"> </span>0,<span class="heti-spacing"> </span></span>因此<span class="heti-skip"><span class="heti-spacing"> </span>MMU<span class="heti-spacing"> </span></span>触发异常<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>控制传递到缺页异常处理程序<span><span class="heti-spacing"> </span>.</span> </li>
<li>缺页处理程序确定物理内存<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>高速缓存<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>内存<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>中的牺牲页<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>如果如果页面已经被修改了就把它写回到磁盘  </li>
<li>缺页处理程序调入新的页面<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>并更新内存中的<span><span class="heti-spacing"> </span>PTE</span> </li>
<li>缺页处理程序返回到原来的进程<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>再次执行指令<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<p><img alt="" src="https://pic3.zhimg.com/80/v2-f1fb3ab51c195870ebe17b17172d25b6_1440w.jpg"/></p>
</li>
</ul>
<h3 id="_12"><strong>结合高速缓存和虚拟内存</strong><a class="headerlink" href="#_12" title="Permanent link">¶</a></h3>
<p><img alt="" src="https://pic3.zhimg.com/80/v2-726b784fddaace54a777ef3f39d90322_1440w.jpg"/></p>
<h3 id="tlb"><strong>利用<span class="heti-skip"><span class="heti-spacing"> </span>TLB<span class="heti-spacing"> </span></span>加速地址翻译</strong><a class="headerlink" href="#tlb" title="Permanent link">¶</a></h3>
<p>可以发现每次<span class="heti-skip"><span class="heti-spacing"> </span>CPU<span class="heti-spacing"> </span></span>将一个虚拟地址发送给<span class="heti-skip"><span class="heti-spacing"> </span>MMU<span class="heti-spacing"> </span></span>时<span class="heti-skip"><span class="heti-spacing"> </span>, MMU<span class="heti-spacing"> </span></span>都会将需要的<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>物理地址发送给高速缓存<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>内存来获得<span class="heti-skip"><span class="heti-spacing"> </span>PTE,<span class="heti-spacing"> </span></span>如果高速缓存刚好保存了该<span><span class="heti-spacing"> </span>PTE</span>，则<span class="heti-skip"><span class="heti-spacing"> </span>MMU<span class="heti-spacing"> </span></span>可以很快获得<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>否则需要等待很多时钟周期从内存中读取<span><span class="heti-spacing"> </span>.</span> </p>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span>MMU<span class="heti-spacing"> </span></span>中有一个关于<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>的小的缓存<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>称为<strong>快表<span><span class="heti-spacing"> </span>(Translation Lookaside Buffer, TLB)</span></strong>. <strong>TLB</strong> 是一个小的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>虚拟寻址的缓存<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>其中每一行都保存着一个由单个<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>组成块<span><span class="heti-spacing"> </span>.</span> <strong>TLB</strong> 通常有高度的相联度<span><span class="heti-spacing"> </span>.</span> </p>
<p><img alt="20220904104846" src="https://s2.loli.net/2022/09/04/pQVhk3eKncHW87B.png"/></p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span>TLB<span class="heti-spacing"> </span></span>有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T=2^t\)</span><span class="heti-spacing"> </span></span>个组<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>那么<strong><span>TLB<span class="heti-spacing"> </span></span>索引<span><span class="heti-spacing"> </span>(TLBI)</span></strong> 是由<span class="heti-skip"><span class="heti-spacing"> </span>VPN<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>t<span class="heti-spacing"> </span></span>个最低位组成的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>而<strong><span>TLB<span class="heti-spacing"> </span></span>标记<span><span class="heti-spacing"> </span>(TLBT)</span></strong> 是由<span class="heti-skip"><span class="heti-spacing"> </span>VPN<span class="heti-spacing"> </span></span>中剩余的位组成的<span><span class="heti-spacing"> </span>.</span> </p>
<div align="center"> <img src="https://s2.loli.net/2022/09/04/OSNco8MYzLCgE6F.png" width="65%/"/> </div>
<ul>
<li>
<p><strong><span>TLB<span class="heti-spacing"> </span></span>命中</strong></p>
<ul>
<li><span>CPU<span class="heti-spacing"> </span></span>产生一个虚拟地址</li>
<li><span>MMU<span class="heti-spacing"> </span></span>从<span class="heti-skip"><span class="heti-spacing"> </span>TLB<span class="heti-spacing"> </span></span>中取出相应的<span class="heti-skip"><span class="heti-spacing"> </span>PTE(PPN<span class="heti-spacing"> </span></span>和标记位<span><span class="heti-spacing"> </span>)</span><ul>
<li><span>TLB<span class="heti-spacing"> </span></span>对<span class="heti-skip"><span class="heti-spacing"> </span>VPN<span class="heti-spacing"> </span></span>进行分解，得到<span class="heti-skip"><span class="heti-spacing"> </span>TLBI<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>TLBT</span>，根据<span class="heti-skip"><span class="heti-spacing"> </span>TLBI<span class="heti-spacing"> </span></span>确定所在的高速缓存组，然后在高速缓存组中依次比较各个高速缓存行的标记是否和<span class="heti-skip"><span class="heti-spacing"> </span>TLBT<span class="heti-spacing"> </span></span>相同，如果相同，则<span class="heti-skip"><span class="heti-spacing"> </span>TLB<span class="heti-spacing"> </span></span>命中，将对应的<span class="heti-skip"><span class="heti-spacing"> </span>PPN<span class="heti-spacing"> </span></span>发送给<span><span class="heti-spacing"> </span>MMU.</span> </li>
</ul>
</li>
<li><span>MMU<span class="heti-spacing"> </span></span>将这个虚拟地址翻译为物理地址<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>并将它发送到高速缓存<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>主存</li>
<li>高速缓存<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>主存将所请求的数据字返回给<span><span class="heti-spacing"> </span>CPU</span></li>
</ul>
</li>
<li>
<p><strong><span>TLB<span class="heti-spacing"> </span></span>不命中</strong>
    MMU 必须从 L1 缓存中取出相应的 PTE, 可能覆盖一个原有的条目.  </p>
</li>
</ul>
<h3 id="_13"><strong>多级页表</strong><a class="headerlink" href="#_13" title="Permanent link">¶</a></h3>
<p>假设我们有一个<span class="heti-skip"><span class="heti-spacing"> </span>32<span class="heti-spacing"> </span></span>位的地址空间<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>页面大小为<span class="heti-skip"><span class="heti-spacing"> </span>4KB, PTE<span class="heti-spacing"> </span></span>大小为<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>字节<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>那么无论被使用的虚拟地址空间多小<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>我们都需要一个<span class="heti-skip"><span class="heti-spacing"> </span>4MB<span class="heti-spacing"> </span></span>的页表驻留在内存中<span><span class="heti-spacing"> </span>.</span> </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在上面的例子中<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>页面大小<span class="heti-skip"><span class="heti-spacing"> </span>4KB<span class="heti-spacing"> </span></span>即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(4*2^{10}=2^{12}\)</span> bytes.<span class="heti-spacing"> </span></span>我们需要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(2^{32}/2^{12} = 2^20\)</span><span class="heti-spacing"> </span></span>个页面<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这也就需要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(2^20\)</span><span class="heti-spacing"> </span></span>个<span class="heti-skip"><span class="heti-spacing"> </span>PTE.<span class="heti-spacing"> </span></span>因此页表大小为<span><span class="heti-spacing"> </span><span class="arithmatex">\(2^20 \times 4 = 4 MB\)</span></span></p>
</div>
<p>我们可以构造多级页表来压缩内容<span><span class="heti-spacing"> </span>:</span> </p>
<p><img alt="" src="https://pic2.zhimg.com/80/v2-f908ebabd94ab4047505fa2ea40237cd_1440w.jpg"/></p>
<p>一级页表中每个<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>负责映射虚拟地址空间中一个<span class="heti-skip"><span class="heti-spacing"> </span>4MB<span class="heti-spacing"> </span></span>的<strong>片<span><span class="heti-spacing"> </span>(chunk)</span></strong><span>,<span class="heti-spacing"> </span></span>这里每一片都是由<span class="heti-skip"><span class="heti-spacing"> </span>1024<span class="heti-spacing"> </span></span>个连续页面组成<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>因此二级页表中每一个片对应<span class="heti-skip"><span class="heti-spacing"> </span>1024<span class="heti-spacing"> </span></span>个<span class="heti-skip"><span class="heti-spacing"> </span>PTE).<span class="heti-spacing"> </span></span>对于<span class="heti-skip"><span class="heti-spacing"> </span>4GB<span class="heti-spacing"> </span></span>的地址空间<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>一级页表中<span class="heti-skip"><span class="heti-spacing"> </span>1024<span class="heti-spacing"> </span></span>个<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>已经足够覆盖整个内存空间<span><span class="heti-spacing"> </span>.</span> <br/>
如果片 i 中的每个页面都未被分配, 那么其一级 PTEi 就为空. 如果至少有一个页是分配了的, 那么一级 PTEi 就指向一个二级页表的基址.  </p>
<p>二级页表中每个<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>负责映射一个<span class="heti-skip"><span class="heti-spacing"> </span>4KB<span class="heti-spacing"> </span></span>的虚拟内存界面<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>我们一级和二级页表的<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>大小都是<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>字节<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>因此页表都是<span class="heti-skip"><span class="heti-spacing"> </span>4KB<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>刚好与页面大小一致<span><span class="heti-spacing"> </span>.</span> </p>
<p>这种方法减少了内存要求<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li>如果一级页表中的一个<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>是空的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>那么二级页表根本不会存在<span><span class="heti-spacing"> </span>.</span> </li>
<li>只有一级页表才需要总是在内存中<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>虚拟内存系统可以在需要时创建<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>页面调入或调出二级页表<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这减少了主存的压力<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>只有最经常使用的二级页表才需要缓存在主存 中<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<p><img alt="20220904143438" src="https://s2.loli.net/2022/09/04/UeRg1SJPAqrhcaZ.png"/></p>
<h3 id="intel-core-i7linux"><strong>案例分析<span class="heti-skip"><span class="heti-spacing"> </span>: Intel Core i7/Linux<span class="heti-spacing"> </span></span>内存系统</strong><a class="headerlink" href="#intel-core-i7linux" title="Permanent link">¶</a></h3>
<p><span>Core i7<span class="heti-spacing"> </span></span>支持<span class="heti-skip"><span class="heti-spacing"> </span>48<span class="heti-spacing"> </span></span>位虚拟地址空间和<span class="heti-skip"><span class="heti-spacing"> </span>52<span class="heti-spacing"> </span></span>位物理地址空间<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>还兼容<span class="heti-skip"><span class="heti-spacing"> </span>32<span class="heti-spacing"> </span></span>位虚拟和物理地址空间<span><span class="heti-spacing"> </span>.</span> </p>
<p><img alt="" src="https://pic1.zhimg.com/80/v2-213b3616089dccf18855bf5f90360b64_1440w.jpg"/></p>
<h4 id="core-i7"><strong><span>Core i7<span class="heti-spacing"> </span></span>地址翻译</strong><a class="headerlink" href="#core-i7" title="Permanent link">¶</a></h4>
<p><span>Core i7<span class="heti-spacing"> </span></span>采用四级页表层次结构<span class="heti-skip"><span class="heti-spacing"> </span>. CR3<span class="heti-spacing"> </span></span>控制寄存器指向第一级页表<span class="heti-skip"><span class="heti-spacing"> </span>(L1)<span class="heti-spacing"> </span></span>的起始位置<span class="heti-skip"><span class="heti-spacing"> </span>. CR3<span class="heti-spacing"> </span></span>的值是每个进程上下文的一部分<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>每次上下文切换时<span class="heti-skip"><span class="heti-spacing"> </span>CR3<span class="heti-spacing"> </span></span>的值都会被恢复<span><span class="heti-spacing"> </span>.</span> <br/>
页大小可以在启动时被配置为 4KB 或 4MB. Linux 使用的是 4KB 的页, 因此 <span class="arithmatex">\(p=12\)</span>.  </p>
<p><img alt="" src="https://pic4.zhimg.com/80/v2-e1b76ebb8e05c66f3a1d3aefe3e8ca07_1440w.jpg"/></p>
<p>其中每个<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span>8<span class="heti-spacing"> </span></span>字节<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这里要求物理页<span class="heti-skip"><span class="heti-spacing"> </span>4KB<span class="heti-spacing"> </span></span>对齐<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>由于物理地址为<span class="heti-skip"><span class="heti-spacing"> </span>52<span class="heti-spacing"> </span></span>位<span class="heti-skip"><span class="heti-spacing"> </span>,  PPO<span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span>12<span class="heti-spacing"> </span></span>位<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>则<span class="heti-skip"><span class="heti-spacing"> </span>PPN<span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span>40<span class="heti-spacing"> </span></span>位<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>所以这里的页表物理基地址为<span class="heti-skip"><span class="heti-spacing"> </span>40<span class="heti-spacing"> </span></span>位<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这里增加了<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>个权限位来控制对页的访问<span><span class="heti-spacing"> </span>:</span> <code>R/W</code>、<code>U/S</code>和<code>XD</code><span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>其中<code>XD</code>是<span class="heti-skip"><span class="heti-spacing"> </span>64<span class="heti-spacing"> </span></span>位系统引入的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>限制了只能在只读代码段执行<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>降低了缓冲区溢出攻击的风险。此外<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>当<span class="heti-skip"><span class="heti-spacing"> </span>MMU<span class="heti-spacing"> </span></span>访问一个页时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>会设置<strong>引用位<span><span class="heti-spacing"> </span>(Reference Bit)</span></strong> <span>A<span class="heti-spacing"> </span></span>位<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>让内核实现页替换算法<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>当<span class="heti-skip"><span class="heti-spacing"> </span>MMU<span class="heti-spacing"> </span></span>修改一个页时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>会设置<strong>脏位<span><span class="heti-spacing"> </span>(Dirty Bit)</span></strong> <span>D<span class="heti-spacing"> </span></span>位<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>使得内核对牺牲页进行写回<span><span class="heti-spacing"> </span>.</span> </p>
<p><img alt="" src="https://pic3.zhimg.com/80/v2-e0dd09cffcc5a3056ee948c54c0c4dca_1440w.jpg"/></p>
<p>总体流程图<span><span class="heti-spacing"> </span>:</span><br/>
<img alt="" src="https://pic4.zhimg.com/80/v2-86ce97e0911a010841b6f7473df84f77_1440w.jpg"/> </p>
<div class="admonition info">
<p class="admonition-title">高速缓存</p>
<p>最后物理地址的<span class="heti-skip"><span class="heti-spacing"> </span>52<span class="heti-spacing"> </span></span>位中<span class="heti-skip"><span class="heti-spacing"> </span>, CT<span class="heti-spacing"> </span></span>表示标志位<span class="heti-skip"><span class="heti-spacing"> </span>, CI<span class="heti-spacing"> </span></span>表示组索引<span class="heti-skip"><span class="heti-spacing"> </span>, CO<span class="heti-spacing"> </span></span>表示块偏移<span><span class="heti-spacing"> </span>.</span><br/>
这里可以发现一个特点: 高速缓存的 <span class="arithmatex">\(CI+CO=12\)</span> 位, 而 VPO 也是 12 位. 这不是巧合, 而是故意这样设计来加速地址翻译. 我们知道, VPO=PPO, 而 PPN 需要通过地址翻译获得, 则一开始输入虚拟地址时, 就能一下等到 PPO, 然后等待检索 PPN. 此时我们就能直接将 PPO 输入到高速缓存中, 因为PPO确定了对应的高速缓存组和块偏移量, 就能先通过 PPO 获得对应的高速缓存组, 然后只要等检索到 PPN 时, 就能直接和高速缓存组中每一行的标志位进行比较, 极大加速了地址翻译过程.  </p>
</div>
<h4 id="linux"><strong><span>Linux<span class="heti-spacing"> </span></span>虚拟内存系统</strong><a class="headerlink" href="#linux" title="Permanent link">¶</a></h4>
<p><span>Linux<span class="heti-spacing"> </span></span>为每个进程都维护了一个单独的虚拟地址空间<span><span class="heti-spacing"> </span>.</span><br/>
<img alt="" src="https://pic2.zhimg.com/80/v2-b2530b84adf0fa21b6c0852aafac61bd_1440w.jpg"/></p>
<p>其中内核虚拟内存包括内核中的代码和数据结构<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>内核虚拟内存的某些区域被映射到所有进程共享的物理页面<span class="heti-skip"><span class="heti-spacing"> </span>. Linux<span class="heti-spacing"> </span></span>还将一组连续的虚拟页面<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>大小等于系统中<span class="heti-skip"><span class="heti-spacing"> </span>DRAM<span class="heti-spacing"> </span></span>总量<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>映射到相应的一组连续的物理页面<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这样内核可以在这个虚拟内存上进行读写，实际上就是对物理内存进行读写<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这为内核提供一种便利的方法来访问物理内存。这部分内容对所有进程都是一样的<span><span class="heti-spacing"> </span>.</span> </p>
<h4 id="linux_1"><strong><span>Linux<span class="heti-spacing"> </span></span>虚拟内存区域</strong><a class="headerlink" href="#linux_1" title="Permanent link">¶</a></h4>
<p><span>Linux<span class="heti-spacing"> </span></span>将虚拟内存组织成一些<strong>区域</strong><span>(<span class="heti-spacing"> </span></span>也叫<strong>段</strong><span>)<span class="heti-spacing"> </span></span>的集合<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>一个<strong>区域</strong>就是已经存在着的<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>已分配<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>虚拟内存的连续片<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这些页是以某种方式相关联的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>如代码段、数据段、共享库段以及用户栈<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这种组织成段的形式<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>允许虚拟地址空间存在间隙<span><span class="heti-spacing"> </span>.</span> </p>
<p>内核为系统中每个进程维护一个单独的任务结构<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>源代码中的<code>task_struct</code><span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>存于最上面那块<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>其中包括运行该进程所需要的所有信息<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>其中有一个条目指向<code>mm_struct</code><span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>它描述了虚拟内存的当前状态<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>它包含两个有趣的字段<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><code>pgd</code><span>:<span class="heti-spacing"> </span></span>指向第一级页表<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>页全局目录<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>的基址<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>当内核运行进程时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>就把<code>pgd</code>放在<span class="heti-skip"><span class="heti-spacing"> </span>CR3<span class="heti-spacing"> </span></span>控制寄存器下<span><span class="heti-spacing"> </span>.</span> </li>
<li>
<p><code>mmap</code><span>:<span class="heti-spacing"> </span></span>指向一个<code>vm_area_struct</code><span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>区域结构<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>的链表<span><span class="heti-spacing"> </span>.</span> </p>
<ul>
<li><code>vm_start</code><span>:<span class="heti-spacing"> </span></span>指向这个区域的起始处   </li>
<li><code>vm_end</code><span>:<span class="heti-spacing"> </span></span>指向这个区域的结束处  </li>
<li><code>vm_prot</code><span>:<span class="heti-spacing"> </span></span>描述这个区域内包含的所有页的读写许可权限  </li>
<li><code>vm_flags</code><span>:<span class="heti-spacing"> </span></span>描述这个区域内的页面是与其他进程共享的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>还是这个进程私有的  </li>
<li><code>vm_next</code><span>:<span class="heti-spacing"> </span></span>指向链表中下一个结构  </li>
</ul>
</li>
</ul>
<p><img alt="" src="https://pic1.zhimg.com/80/v2-ccd8e84202d3c044aa06bb2ec58c68e0_1440w.jpg"/></p>
<h4 id="linux_2"><strong><span>Linux<span class="heti-spacing"> </span></span>缺页异常处理</strong><a class="headerlink" href="#linux_2" title="Permanent link">¶</a></h4>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span>MMU<span class="heti-spacing"> </span></span>在试图翻译某个虚拟地址<span class="heti-skip"><span class="heti-spacing"> </span>A<span class="heti-spacing"> </span></span>时触发了一个缺页<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>处理程序随后执行下面的步骤<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><strong>虚拟地址<span class="heti-skip"><span class="heti-spacing"> </span>A<span class="heti-spacing"> </span></span>是否合法</strong><span>: A<span class="heti-spacing"> </span></span>是否是在某个区域结构定义的区域内<span class="heti-skip"><span class="heti-spacing"> </span>?<span class="heti-spacing"> </span></span>处理程序会把<span class="heti-skip"><span class="heti-spacing"> </span>A<span class="heti-spacing"> </span></span>与每个区域结构的<code>vm_start</code>和<code>vm_end</code>做比较<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如果指令不合法<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>程序触发一个段错误<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>终止进程<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>对地址<span class="heti-skip"><span class="heti-spacing"> </span>A<span class="heti-spacing"> </span></span>的访问是否合法</strong><span>:<span class="heti-spacing"> </span></span>进程是否有读写或者执行这个区域内页面的权限<span class="heti-skip"><span class="heti-spacing"> </span>?<span class="heti-spacing"> </span></span>如果访问不合法<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>程序会触发一个保护异常<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>终止进程<span><span class="heti-spacing"> </span>.</span> </li>
<li>正常的缺页处理<span class="heti-skip"><span class="heti-spacing"> </span>:<span class="heti-spacing"> </span></span>选择一个牺牲页<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>如果被修改了就写回<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>随后将虚拟地址<span class="heti-skip"><span class="heti-spacing"> </span>A<span class="heti-spacing"> </span></span>对应的虚拟页写入物理页中<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>修改页表<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>从处理程序返回<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<h2 id="_14"><strong>内存映射</strong><a class="headerlink" href="#_14" title="Permanent link">¶</a></h2>
<p><span>Linux<span class="heti-spacing"> </span></span>通过将一个虚拟内存区域与一个磁盘上的<strong>对象<span><span class="heti-spacing"> </span>(object)</span></strong> 关联起来<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>以初始化这个虚拟内存区域的内容<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这个过程称为<strong>内存映射<span><span class="heti-spacing"> </span>(memory mapping)</span></strong>.<br/>
虚拟内存区域可以映射到两种类型的对象中的一种:  </p>
<ul>
<li><strong><span>Linux<span class="heti-spacing"> </span></span>文件系统中的普通文件</strong><br/>
一个区域可以映射到一个普通磁盘文件的连续部分, 例如一个可执行目标文件. <strong>文件区<span><span class="heti-spacing"> </span>(section)</span></strong> 被分成页大小的片<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>用来初始化对应的虚拟内存段<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>如果段比文件大<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>则用<span class="heti-skip"><span class="heti-spacing"> </span>0<span class="heti-spacing"> </span></span>来填充剩下的内容<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>然后按需将虚拟页复制到物理页中<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>匿名文件</strong><br/>
一个区域也可以映射到一个匿名文件, 匿名文件是由内核创建的, 包含的全是二进制零.  因此映射到匿名文件的区域中的页面也被称为<strong>请求二进制零的页<span><span class="heti-spacing"> </span>(demand-zero page)</span></strong>.  </li>
</ul>
<p>一旦一个虚拟页面被初始化了<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>它就在一个由内核维护的专门的<strong>交换文件</strong>之间换来换去<span><span class="heti-spacing"> </span>.</span> <strong>交换文件</strong>也叫做<strong>交换空间</strong>或者<strong>交换区域</strong><span>.<span class="heti-spacing"> </span></span>交换空间限制当前进程能够分配的虚拟页面的总数<span><span class="heti-spacing"> </span>.</span> </p>
<h3 id="_15"><strong>共享对象</strong><a class="headerlink" href="#_15" title="Permanent link">¶</a></h3>
<p>一个对象可以被映射到虚拟内存中的一个区域<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>要么作为<strong>共享对象</strong><span>,<span class="heti-spacing"> </span></span>要么作为<strong>私有对象</strong><span>.<span class="heti-spacing"> </span></span>映射到共享对象的虚拟内存区域叫<strong>共享区域</strong><span>,<span class="heti-spacing"> </span></span>类似地有<strong>私有区域</strong>.  </p>
<ul>
<li>如果一个进程将一个共享对象映射到它虚拟地址空间的一个区域内<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>那么这个进程对这个区域的任何写操作<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>对于那些也这样做的进程而言<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>也是可见的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>而且这些变化会反映到磁盘上的原始对象中<span><span class="heti-spacing"> </span>.</span> </li>
<li>对于一个映射到私有对象的区域的改变<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>对其他进程是不可见的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>而且变化不会反映到磁盘上的对象中<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<p><img alt="" src="https://pic3.zhimg.com/80/v2-0b53b0811649418b21ff97397d3d5cea_1440w.jpg"/></p>
<p>在进程<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>中，当我们将磁盘上的一个对象通过内存映射与该进程的一个共享段关联起来时，就会使得虚拟页对应的<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>指向该对象，当引用该对象时，就会将对应的虚拟页加载到物理页中；而进程<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>也要将该对象与自己的一个共享段关联起来时，当对其引用时，由于每个对象都有一个唯一的文件名，所以内核可以发现进程<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>将该对象加载的物理页，就直接在进程<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>中将对应的<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>指向相同的物理页就行了<span><span class="heti-spacing"> </span>.</span> <br/>
<strong>注</strong><span>:<span class="heti-spacing"> </span></span>进程<span class="heti-skip"><span class="heti-spacing"> </span>½<span class="heti-spacing"> </span></span>的虚拟地址空间不同<span class="heti-skip"><span class="heti-spacing"> </span>;<span class="heti-spacing"> </span></span>即使一个对象与多个进程的共享段管理<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>物理内存中只放共享对象的一个副本<span><span class="heti-spacing"> </span>.</span> </p>
<p>私有对象使用<strong>写时复制<span><span class="heti-spacing"> </span>(copy-on-write)</span></strong> 的方法<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>未对私有对象进行修改时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>物理内存中只会保存同一个对象副本<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>且各个进程中对该对象的<span class="heti-skip"><span class="heti-spacing"> </span>PTE<span class="heti-spacing"> </span></span>都是只读的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>而虚拟内存段标记为<strong>私有的写时复制</strong>.<br/>
只要没有进程试图写它自己的私有区域, 它们就可以继续共享物理内存中对象的一个副本.<br/>
<img alt="" src="https://pic3.zhimg.com/80/v2-18e85df69e0f73a69c9dbe78a27c9e0a_1440w.jpg"/>
但当有进程试图写私有区域的某个局面时, 会触发一个保护故障. 故障处理程序会在物理内存中创建这个页面的一个新副本, 更新 PTE 指向新副本, 然后恢复这个页面的可写权限. 故障处理程序返回后重新执行写操作即可.<br/>
<img alt="" src="https://pic2.zhimg.com/80/v2-014b5d2b14b41ebb8830b9f262f9108d_1440w.jpg"/></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>图中大块的表示对象，可能由很多个页组成，当我们尝试对其中一个页进行修改时，<strong>只会对该页进行复制</strong>，并修改该页对应的<span><span class="heti-spacing"> </span>PTE</span>，而<strong>该对象的其他页保持不变<span><span class="heti-spacing"> </span>.</span></strong> </p>
</div>
<p>通过写时复制这种策略，尽可能延迟物理内存中的拷贝，能最大效率地使用物理内存<span><span class="heti-spacing"> </span>.</span> </p>
<h3 id="fork"><strong><code>fork</code>函数</strong><a class="headerlink" href="#fork" title="Permanent link">¶</a></h3>
<p>当<code>fork</code>函数被当前进程调用时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>内核为新进程创建各种数据结构<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>并分配给它唯一的<span class="heti-skip"><span class="heti-spacing"> </span>PID.<span class="heti-spacing"> </span></span>为了创建一个独立虚拟地址空间<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>我们使用写时复制的技术<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li>为了具有和父进程相同的虚拟内存状态，内核会复制父进程的<code>mm_struct</code></li>
<li>为了具有和父进程相同的虚拟内存段分配，内核会复制父进程的<code>vm_area_struct</code><span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>区域结构<span><span class="heti-spacing"> </span>)</span></li>
<li>为了子进程和父进程具有相同的虚拟内存内容，内核会复制父进程的页表，就能将相同的磁盘内容映射到相同的虚拟页中，并将虚拟页缓存在相同的物理页中<span><span class="heti-spacing"> </span>.</span> </li>
<li>为了子进程和父进程的虚拟地址空间能相互独立，两个进程的页都设置为只读的，且段都标记为私有的写回复制。当父子进程都没有对页进行修改时，父子进程是共享相同的物理内存的，当其中一个进程对页进行修改时，就会对该页进行写回复制，并为该页赋予写权限，并更新进程对应的页表<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<h3 id="execve"><strong><code>execve</code>函数</strong><a class="headerlink" href="#execve" title="Permanent link">¶</a></h3>
<p>当我们运行<code>execve("a.out", NULL, NULL);</code>时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>加载并允许<code>a.out</code>需要以下步骤<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><strong>删除已存在的用户区域</strong><span>:<span class="heti-spacing"> </span></span>删除当前进程虚拟地址的用户部分已存在的区域结构<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>即<code>vm_area_struct</code>和页表<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>映射私有区域</strong><span>:<span class="heti-spacing"> </span></span>为新程序的代码<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>数据<span class="heti-skip"><span class="heti-spacing"> </span>, bss<span class="heti-spacing"> </span></span>和栈区域创建新的区域结构<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>映射共享区域</strong><span>:<span class="heti-spacing"> </span></span>如果与共享对象链接<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>如共享库<span class="heti-skip"><span class="heti-spacing"> </span>),<span class="heti-spacing"> </span></span>那么在<code>vm_area_struct</code>中创建一个共享段<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>然后将其与共享库的内容关联起来<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>设置程序计数器<span><span class="heti-spacing"> </span>(PC)</span></strong><span>:<span class="heti-spacing"> </span></span>使其指向代码段的入口点<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<p><img alt="" src="https://pic1.zhimg.com/80/v2-82fdc58ea80f8939f822ba31de34771c_1440w.jpg"/></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>当程序运行时，我们并没有加载任何内容到内存中，所做的只是设置内存映射，在内核中创建数据结构，由此创建了虚拟地址空间和这些对象之间的映射关系，而实际的拷贝工作会由缺页异常按需完成<span><span class="heti-spacing"> </span>.</span> </p>
</div>
<h3 id="mmap"><strong><code>mmap</code>函数的用户级内存映射</strong><a class="headerlink" href="#mmap" title="Permanent link">¶</a></h3>
<p><span>Linux<span class="heti-spacing"> </span></span>进程可以使用<code>mmap</code>函数来创建新的虚拟内存区域<span><span class="heti-spacing"> </span>.</span><br/>
</p><div class="highlight"><pre><span></span><code><a href="#__codelineno-0-1" id="__codelineno-0-1" name="__codelineno-0-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<a href="#__codelineno-0-2" id="__codelineno-0-2" name="__codelineno-0-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/mman.h&gt;</span>
<a href="#__codelineno-0-3" id="__codelineno-0-3" name="__codelineno-0-3"></a><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">mmap</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">off_t</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
</code></pre></div>
<code>mmap</code>函数要求内核创建一个新的虚拟内存区域, 最好是从地址 start 开始的一个区域, 并将文件描述符号 fd 指定的对象的一个连续的片映射到这个新的区域. 连续对象的片的长度为 length 字节, 从距文件开始偏移量为 offset 字节的地方开始. start 可设为 NULL, 让内核自动分配.  
<p><img alt="" src="https://pic3.zhimg.com/80/v2-70f262ad8db13777520bfd9f409fe4ee_1440w.jpg"/></p>
<p>其中，<span>prot<span class="heti-spacing"> </span></span>对应于段结构中的<code>vm_prot</code>参数，用来确定该虚拟内存段的读写权限：<code>PROT_EXEC</code>表示该段中的页是可执行的；<code>PROT_READ</code>表示该段中的页是可读的；<code>PROT_WRITE</code>表示该段中的页是可写的；<code>PROT_NONE</code>表示该段内的页是不可访问的<span><span class="heti-spacing"> </span>.</span> </p>
<p><span>flags<span class="heti-spacing"> </span></span>对应于段结构中的<code>vm_flags</code><span class="heti-skip"><span class="heti-spacing"> </span>:<span class="heti-spacing"> </span></span><code>MAP_PRIVATE</code>表示该段是私有的写时复制的；<code>MAP_SHARED</code>表示该段是共享的。也可以设置<code>MAP_ANON</code>，表示是一个匿名对象<span><span class="heti-spacing"> </span>.</span> </p>
<p>当函数执行成功时，会返回指向该段的指针，如果失败，则返回<code>MAP_FAILED</code><span><span class="heti-spacing"> </span>.</span> </p>
<p><code>munmap</code>函数删除从虚拟地址<span class="heti-skip"><span class="heti-spacing"> </span>start<span class="heti-spacing"> </span></span>开始<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>由接下来<span class="heti-skip"><span class="heti-spacing"> </span>length<span class="heti-spacing"> </span></span>字节组成的虚拟内存区域 <br/>
</p><div class="highlight"><pre><span></span><code><a href="#__codelineno-1-1" id="__codelineno-1-1" name="__codelineno-1-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<a href="#__codelineno-1-2" id="__codelineno-1-2" name="__codelineno-1-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/mman.h&gt;</span>
<a href="#__codelineno-1-3" id="__codelineno-1-3" name="__codelineno-1-3"></a><span class="kt">int</span><span class="w"> </span><span class="nf">munmap</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"> </span>
</code></pre></div>
<div class="admonition info">
<p class="admonition-title">内存映射的好处</p>
<ul>
<li>使得磁盘文件中的一块数据能与虚拟内存地址空间中的某个段建立映射关系，此时我们就能直接通过对该虚拟内存段的访问来间接访问磁盘文件内容，不必执行文件<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>操作，也无需对文件内容进行缓存处理。并且虚拟内存进行按需页面调度的，当你访问了文件内容，它就会将对应的虚拟页加载到物理页中，此时就能从内存中很快地访问文件内容。当你处理大文件或频繁读写文件时能提速，因为此时就直接将文件内容加载到物理内存中了，一切读写操作都是在物理内存中进行的，速度特别快，只有在内核将其牺牲时，才会进行写回<span><span class="heti-spacing"> </span>.</span> </li>
<li>通过内存映射方法，我们还能定义一个进程共享的虚拟内存段，使得能让多个进程对一个区域进行访问和修改<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
</div>
<h2 id="_16"><strong>动态内存分配</strong><a class="headerlink" href="#_16" title="Permanent link">¶</a></h2>
<p>虽然可以使用<code>mmap</code>和<code>munmap</code>来创建和删除虚拟内存的区域<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>但是<span class="heti-skip"><span class="heti-spacing"> </span>C<span class="heti-spacing"> </span></span>程序员用<strong>动态内存分配器<span><span class="heti-spacing"> </span>(dynamic memory allocator)</span></strong> 更方便<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>也有更好的移植性<span><span class="heti-spacing"> </span>.</span> </p>
<p><strong>动态内存分配器</strong>维护着一个进程的虚拟内存区域<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>称为<strong>堆<span><span class="heti-spacing"> </span>(heap)</span></strong><span>.<span class="heti-spacing"> </span></span>对于每个进程内核都维护一个变量<span class="heti-skip"><span class="heti-spacing"> </span>brk,<span class="heti-spacing"> </span></span>它指向堆的顶部<span><span class="heti-spacing"> </span>.</span> </p>
<div align="center"> <img src="https://s2.loli.net/2022/09/05/tcCPjQSRXJ2GqM5.png" width="60%/"/> </div>
<p>分配器将堆视为一组不同大小的块的集合来维护<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>每个块就是一个连续的虚拟内存片<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>要么是已分配的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>要么是空闲的<span><span class="heti-spacing"> </span>.</span> </p>
<p>分配器有两种风格<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>都要求应用显式地分配块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>不同在于由哪个实体负责释放已分配的块<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><strong>显式分配器<span><span class="heti-spacing"> </span>(explicit allocator)</span></strong><span>:<span class="heti-spacing"> </span></span>要求应用显式地释放任何已分配的块<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如<span class="heti-skip"><span class="heti-spacing"> </span>C<span class="heti-spacing"> </span></span>语言中的<code>malloc``free</code>函数<span class="heti-skip"><span class="heti-spacing"> </span>, C++<span class="heti-spacing"> </span></span>中的<code>new``delete</code>函数<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>隐式分配器<span><span class="heti-spacing"> </span>(implicit allocator)</span></strong><span>:<span class="heti-spacing"> </span></span>要求分配器检测一个已分配块何时不再被程序所使用<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>那么就释放这个块<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>隐式分配器也叫<strong><em>垃圾收集器<span><span class="heti-spacing"> </span>(garbage collector)</span></em><span>*,<span class="heti-spacing"> </span></span>自动释放未使用的已分配的块的过程叫</strong>垃圾收集<span><span class="heti-spacing"> </span>**.</span> </li>
</ul>
<div class="admonition info">
<p class="admonition-title">为什么要使用动态内存分配</p>
<p>经常直到程序实际运行时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>才知道某些数据结构的大小<span><span class="heti-spacing"> </span>.</span> </p>
</div>
<h3 id="_17"><strong>显式分配器</strong><a class="headerlink" href="#_17" title="Permanent link">¶</a></h3>
<h4 id="mallocfree"><strong><code>malloc</code>和<code>free</code>函数</strong><a class="headerlink" href="#mallocfree" title="Permanent link">¶</a></h4>
<p>程序可以通过<code>malloc</code>函数来显示地从堆中分配块</p>
<p></p><div class="highlight"><pre><span></span><code><a href="#__codelineno-2-1" id="__codelineno-2-1" name="__codelineno-2-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<a href="#__codelineno-2-2" id="__codelineno-2-2" name="__codelineno-2-2"></a><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"> </span>
</code></pre></div>
<code>malloc</code>函数返回一个指针, 指向大小为<strong>至少</strong> <span>size<span class="heti-spacing"> </span></span>字节的内存块<span class="heti-skip"><span class="heti-spacing"> </span>.(<span class="heti-spacing"> </span></span>这个块可能为在这个块内任何数据对象类型做对齐<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>实际中对齐也来编译代码处于<span class="heti-skip"><span class="heti-spacing"> </span>32<span class="heti-spacing"> </span></span>位模式<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span><code>gcc -m32</code><span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>还是<span class="heti-skip"><span class="heti-spacing"> </span>64<span class="heti-spacing"> </span></span>位模式<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span><code>gcc -m64</code><span class="heti-skip"><span class="heti-spacing"> </span>). 32<span class="heti-spacing"> </span></span>位模式中<code>malloc</code>返回的块的地址总是<span class="heti-skip"><span class="heti-spacing"> </span>8<span class="heti-spacing"> </span></span>的倍数<span class="heti-skip"><span class="heti-spacing"> </span>, 64<span class="heti-spacing"> </span></span>位模式中地址总是<span class="heti-skip"><span class="heti-spacing"> </span>16<span class="heti-spacing"> </span></span>的倍数<span><span class="heti-spacing"> </span>.</span><br/>
如果<code>malloc</code>遇到问题, 如要求的内存块比可用的虚拟内存还要大, 那么就返回 NULL, 并设置 errn. <code>malloc</code>不初始化返回的内存, <code>calloc</code>会将内存初始为 0. <code>realloc</code>可以用来改变一个以前已分配块的大小.  
<p>程序可以通过<code>free</code>函数来释放已分配的堆块
</p><div class="highlight"><pre><span></span><code><a href="#__codelineno-3-1" id="__codelineno-3-1" name="__codelineno-3-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<a href="#__codelineno-3-2" id="__codelineno-3-2" name="__codelineno-3-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></div>
ptr 参数必须指向一个从<code>malloc``calloc``realooc</code>获得的已分配块的起始位置, 如果不是, 那么<code>free</code>的行为就是未定义的, 而且因为他没有返回值, 它也不会告诉应用出现了错误.  
<p>动态内存分配器可以使用<code>mmap</code>和<code>munmap</code>函数，也可以使用<code>sbrk</code>函数来向内核申请堆内存空间，只有先申请获得堆内存空间后，才能尝试对块进行分配让应用程序使用<span><span class="heti-spacing"> </span>.</span><br/>
</p><div class="highlight"><pre><span></span><code><a href="#__codelineno-4-1" id="__codelineno-4-1" name="__codelineno-4-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<a href="#__codelineno-4-2" id="__codelineno-4-2" name="__codelineno-4-2"></a><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">sbrk</span><span class="p">(</span><span class="kt">intptr_t</span><span class="w"> </span><span class="n">incr</span><span class="p">);</span><span class="w"> </span>
</code></pre></div>
<code>sbrk</code>函数将内核的 brk 指针增加 incr 来扩展和收缩堆. 如果成功就返回 brk 的旧值, 否则返回 -1 并设置 errno 为<code>ENOMEM</code>. 如果 incr 为 0 那么 sbrk 就返回 brk 当前值.<br/>
用一个负的 incr 调用<code>sbrk</code>是合法的, 返回值指向新堆顶向上<code>abs(incr)</code>字节处.  
<div class="admonition example">
<p class="admonition-title">Example</p>
<p>本节中我们假设字是<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>字节<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>双字是<span class="heti-skip"><span class="heti-spacing"> </span>8<span class="heti-spacing"> </span></span>字节<span><span class="heti-spacing"> </span>.</span> </p>
<p><img alt="20220905095931" src="https://s2.loli.net/2022/09/05/HI12nfwt4vBGrC9.png"/>
每个方块代表一个 4 字节的字.<br/>
其中 b 即进行了对齐.  </p>
</div>
<h4 id="_18"><strong>分配器的要求和目标</strong><a class="headerlink" href="#_18" title="Permanent link">¶</a></h4>
<p>显示分配器必须在一些相当严格的约束条件下工作<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><strong>处理任意请求序列</strong><br/>
一个应用可以由任意的分配和释放请求序列, 只要满足先分配后释放. 分配器不可以假设分配和释放的顺序.   </li>
<li><strong>立即相应请求</strong><br/>
分配器必须立即相应请求, 不允许分配器为了提高性能重新排列或者缓冲请求.  </li>
<li><strong>只使用堆</strong><br/>
为了使分配器可扩展, 使用的任何非标量数据结构必须保存在堆里.  </li>
<li><strong>对齐块</strong> <br/>
分配器必须对齐块, 使得它们可以保存任何类型的数据对象.  </li>
<li><strong>不修改已分配的块</strong><br/>
分配器只能操作改变空闲块, 一旦块被分配就不允许修改或者移动.  </li>
</ul>
<p>我们有两个性能目标<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><strong>最大化吞吐率</strong><br/>
<strong>吞吐率</strong>定义为每个单位时间里完成的请求数<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>一般我们可以通过使满足分配和释放请求的平均时间最小化来使吞吐率最大化<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>合理性能的分配器指一个分配请求的最糟运行时间与空闲块数量成线性关系<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>而一个释放请求的运行时间是常数<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>最大化内存利用率</strong>
假设 n 个分配和释放的某种序列 <span class="arithmatex">\(R_0, R_1, \ldots, R_k,\ldots, R_{n-1}\)</span>, 用 <span class="arithmatex">\(H_k\)</span> 表示当前堆的大小.    <ul>
<li><strong>有效载荷<span><span class="heti-spacing"> </span>(payload)</span></strong><span>:<span class="heti-spacing"> </span></span>应用程序请求一个<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>字节的块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>那么得到的已分配块的<strong>有效载荷</strong>是<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>字节<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>聚焦有效载荷<span><span class="heti-spacing"> </span>(aggregate payload)</span></strong><span>:<span class="heti-spacing"> </span></span>用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_k\)</span><span class="heti-spacing"> </span></span>表示<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>为当前已分配的有效载荷之和<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>峰值利用率<span><span class="heti-spacing"> </span>(peak utilization)</span></strong>: <strong>峰值利用率</strong>是最常用来评判内存利用率的标准<span><span class="heti-spacing"> </span>.</span><br/>
假设 <span class="arithmatex">\(H_k\)</span> 是单调不递减的, 那么前 k+1 个请求的峰值利用率 <span class="arithmatex">\(U_k=\frac{max_{i&lt;=k}P_i}{H_k}\)</span>. 分配器的目标就是使得 <span class="arithmatex">\(U_{n-1}\)</span> 最大化.<br/>
<strong>注<span><span class="heti-spacing"> </span>:</span></strong> 我们可以放宽单调性假设<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>让<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(H_k\)</span><span class="heti-spacing"> </span></span>表示前<span class="heti-skip"><span class="heti-spacing"> </span>k+1<span class="heti-spacing"> </span></span>个请求的堆的最高峰<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
</li>
</ul>
<p>造成堆利用率低的主要原因之一就是<strong>碎片<span><span class="heti-spacing"> </span>(fragmentation)</span></strong>.  </p>
<ul>
<li><strong>内部碎片</strong><br/>
一个已分配块比有效载荷大, 比如分配器为了满足对齐要求, 就会申请额外的内存空间. 我们可以通过已分配块的大小与其有效载荷的差来量化内部碎片，则内部碎片的数量主要取决于之前请求的模式和分配器的实现方法.   </li>
<li><strong>外部碎片</strong><br/>
当空闲内存合计起来足够满足一个分配请求, 但是没有一个单独的空闲块足够大可以来处理这个请求时发生的. 如图<br/>
<img alt="" src="https://pic2.zhimg.com/80/v2-22f5c91bb8adc9fbb1a24d98c7322efd_1440w.jpg"/>
外部碎片的量化更加困难, 因为它不仅取决于以前请求的模式和分配器的处理方式, 还取决于将来请求的模式. 所以分配器通常采用启发式策略来试图维持少量的大空闲块, 而不是大量的小空闲块.   </li>
</ul>
<p>为了平衡好吞吐率和利用率之间的平衡<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>我们需要考虑几个问题<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><strong>空闲块组织</strong><span>:<span class="heti-spacing"> </span></span>如何记录空闲块<span><span class="heti-spacing"> </span>?</span> </li>
<li><strong>放置</strong><span>:<span class="heti-spacing"> </span></span>如何选择一个合适的空闲块来放置一个新分配的块<span><span class="heti-spacing"> </span>?</span> </li>
<li><strong>分割</strong><span>:<span class="heti-spacing"> </span></span>在将一个新分配的块放到某个空闲块之后<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>如何处理空闲块中的剩余部分<span><span class="heti-spacing"> </span>?</span> </li>
<li><strong>合并</strong><span>:<span class="heti-spacing"> </span></span>如何处理一个刚刚释放的块<span><span class="heti-spacing"> </span>?</span> </li>
</ul>
<h4 id="_19"><strong>隐式空闲链表</strong><a class="headerlink" href="#_19" title="Permanent link">¶</a></h4>
<p><img alt="" src="https://pic3.zhimg.com/80/v2-81b24dfe309b16ef999a9f8903532d2a_1440w.jpg"/></p>
<p>一个块由一个字的头部<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>有效载荷<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>以及可能的一些额外的填充组成的<span><span class="heti-spacing"> </span>.</span> </p>
<ul>
<li><strong>头部</strong><br/>
头部大小为一个字. 头部编码了这个块的大小(块大小包括头部和对齐填充), 以及这个块是否分配.<br/>
如果我们要满足双字对齐, 那么块的大小总是 8 的倍数, 因此块大小的第三位(二进制)总是 0, 我们就用其中的最低位来表示这个块的分配情况.   </li>
<li><strong>有效载荷</strong><br/>
应用<code>malloc</code>请求的有效载荷  </li>
<li><strong>填充</strong><br/>
可选的, 分配器用来满足对齐要求, 或者处理外部碎片.  </li>
</ul>
<p>我们称这种结构为<strong>隐式空闲链表</strong><span>,<span class="heti-spacing"> </span></span>因为空闲块通过头部的大小字段隐含地连接<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>分配器可以便利堆中的所有块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>从而间接地遍历整个空闲块的集合<span><span class="heti-spacing"> </span>.</span><br/>
<strong>注</strong><span>:<span class="heti-spacing"> </span></span>我们需要某种特殊标记的结束块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这个例子中就是一个设置了已分配位而大小为<span class="heti-skip"><span class="heti-spacing"> </span>0<span class="heti-spacing"> </span></span>的<strong>终止头部<span><span class="heti-spacing"> </span>(terminating header)</span></strong>.  </p>
<p><img alt="20220905104737" src="https://s2.loli.net/2022/09/05/G4zFfatBnrmZ79L.png"/></p>
<p>由于地址对齐要求和分配器对块格式的选择，会对最小块的大小有限制，<strong>没有已分配的块和空闲块比最小块还小</strong>，如果比最小块还小，就会变成外部碎片<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>所以最小块越大，内部碎片程度越高<span><span class="heti-spacing"> </span>).</span> </p>
<h4 id="_20"><strong>放置已分配的块</strong><a class="headerlink" href="#_20" title="Permanent link">¶</a></h4>
<p>当一个应用请求一个<span class="heti-skip"><span class="heti-spacing"> </span>k<span class="heti-spacing"> </span></span>字节的块时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>分配器搜索空闲链表<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>查找一个足够大可以放置所请求块的空闲块<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>分配器执行这种搜索的方式是由<strong>放置策略<span><span class="heti-spacing"> </span>(placement policy)</span></strong>确定的<span><span class="heti-spacing"> </span>.</span> </p>
<ul>
<li>
<p><strong>首次适配<span><span class="heti-spacing"> </span>(first fit)</span></strong><span>:<span class="heti-spacing"> </span></span>从头开始搜索空闲链表<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>选择第一个合适的空闲块<span><span class="heti-spacing"> </span>.</span> </p>
<ul>
<li><strong>优点</strong><span>:<span class="heti-spacing"> </span></span>将大的空闲块保留在后面  </li>
<li><strong>缺点</strong><span>:<span class="heti-spacing"> </span></span>在靠近链表起始处留下小空闲块的<span class="heti-skip"><span class="heti-spacing"> </span>"<span class="heti-spacing"> </span></span>碎片<span class="heti-skip"><span class="heti-spacing"> </span>",<span class="heti-spacing"> </span></span>增加了对较大块的搜索时间<span><span class="heti-spacing"> </span>.</span> </li>
<li>
<p><strong>下一次适配<span><span class="heti-spacing"> </span>(next fit)</span></strong><span>:<span class="heti-spacing"> </span></span>从上一次查询结束的地方开始搜索<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>选择第一个合适的空闲块<span><span class="heti-spacing"> </span>.</span> </p>
</li>
<li>
<p><strong>优点</strong><span>:<span class="heti-spacing"> </span></span>运行比首次适配块一些<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>可以跳过开头的碎片    </p>
</li>
<li><strong>缺点</strong><span>:<span class="heti-spacing"> </span></span>内存利用率比首次适配低很多      </li>
<li>
<p><strong>最佳适配<span><span class="heti-spacing"> </span>(best fit)</span></strong><span>:<span class="heti-spacing"> </span></span>检查每个空闲块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>选择适合所需请求大小的最小空闲块<span><span class="heti-spacing"> </span>.</span> </p>
</li>
<li>
<p><strong>优点</strong><span>:<span class="heti-spacing"> </span></span>内存利用率比前两者都高一些</p>
</li>
<li><strong>缺点</strong><span>:<span class="heti-spacing"> </span></span>需要遍历完整的空闲链表  </li>
</ul>
</li>
</ul>
<h4 id="_21"><strong>分割内存块</strong><a class="headerlink" href="#_21" title="Permanent link">¶</a></h4>
<p>一旦分配器找到一个匹配的空闲块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>它必须做另一个策略决定<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>那就是分配空闲块中多少空间<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>一个选择是用整个空闲块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>虽然简单快捷但会产生内部碎片<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如果放置策略倾向于产生较好的匹配那么也可以接收额外的内部碎片<span><span class="heti-spacing"> </span>.</span><br/>
分配器通常会将这个空闲块分割成两部分, 第一部分变成分配块, 而剩下的变成一个新的空闲块.<br/>
<img alt="" src="https://pic3.zhimg.com/80/v2-22433f2f7c39a000805704befba81d0e_1440w.jpg"/></p>
<h4 id="_22"><strong>获取额外的堆内存</strong><a class="headerlink" href="#_22" title="Permanent link">¶</a></h4>
<p>如果分配器不能为请求找到合适的空闲块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>一个选择是通过合并那些在内存中物理相邻的空闲块来创建一些更大的空闲块<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>另一个选择是调用<code>sbrk</code>函数<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>向内核请求额外的堆内存<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>分配器将额外的内存转化为一个大空闲块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>将这个块插入到空闲链表中<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>然后将被请求的块放到这个新的空闲块中<span><span class="heti-spacing"> </span>.</span> </p>
<h4 id="_23"><strong>合并空闲块</strong><a class="headerlink" href="#_23" title="Permanent link">¶</a></h4>
<p>当分配器释放一个已分配块时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>可能会由其他空闲块与中国新释放的空闲块相邻<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这些邻接的空闲块引起一种现象<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>即<strong>假碎片<span><span class="heti-spacing"> </span>(fault fragmentation)</span></strong>.  </p>
<p>分配器可以选择<strong>立即合并</strong>或者<strong>推迟合并</strong>.  </p>
<ul>
<li><strong>立即合并<span><span class="heti-spacing"> </span>(immediate coalescing)</span></strong><span>:<span class="heti-spacing"> </span></span>每次一个块被释放时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>就合并所有的相邻块<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>推迟合并<span><span class="heti-spacing"> </span>(deferred coalescing)</span></strong><span>:<span class="heti-spacing"> </span></span>找不到合适的空闲块时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>再扫描整个堆进行合并<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<p>立即合并简单明了<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>可以在常数时间内完成<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>但对于某些请求模式会产生一种形式的抖动<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>即块反复地合并<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>然后马上被分割<span><span class="heti-spacing"> </span>.</span> </p>
<p>具体实现合并中<span class="heti-skip"><span class="heti-spacing"> </span>:<span class="heti-spacing"> </span></span>合并下一个空闲块是简单高效的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>因为当前块头部指向下一个块的头部<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>只需要检查下一个块的头部<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>看它是否空闲即可<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如果是<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>将大小相加即可<span><span class="heti-spacing"> </span>.</span><br/>
但是合并前一个块, 需要使用<strong>边界标记<span><span class="heti-spacing"> </span>(boundray tag)</span></strong><span>.<span class="heti-spacing"> </span></span>在每个块的结尾处添加一个<strong>脚部<span><span class="heti-spacing"> </span>(footer)</span></strong><span>,<span class="heti-spacing"> </span></span>脚部就是头部的一个副本<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如果每个块都包括这样一个脚部<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>那么分配器可以通过检查它的脚部判断前一个块的位置和状态<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这个脚部总是在距当前块开始位置一个字的距离<span><span class="heti-spacing"> </span>.</span><br/>
<img alt="" src="https://pic2.zhimg.com/80/v2-26d6e84fa75c27e0245852b4c9dc40f1_1440w.jpg"/></p>
<p>可以将情况分为下面几种<span><span class="heti-spacing"> </span>:</span><br/>
<img alt="" src="https://pic3.zhimg.com/80/v2-e6f2612ae7281df6d7155817294184b6_1440w.jpg"/></p>
<ul>
<li>前一块和后一块都是分配的：此时不会发生合并操作<span><span class="heti-spacing"> </span>.</span> </li>
<li>前一块是已分配的，后一块是空闲的：当前块会将头部中的块大小设置为当前块的大小和下一块大小之和，并且修改下一块的脚部<span><span class="heti-spacing"> </span>.</span> </li>
<li>前一块是空闲的，下一块是已分配的：前一块会将头部中的块大小设置为自己的块大小和当前块大小之和，并且修改当前块的脚部<span><span class="heti-spacing"> </span>.</span> </li>
<li>前一块和当前快都是空闲的：前一块会将头部中的块大小设置为这三个块的大小之和，并修改下一块的脚部<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<p>该技术的缺点是会显著增加内存开销，由于引入了脚部，使得有效载荷大小变小，而使得内部碎片变多了，并且最小块的大小变大导致外部碎片也变多了<span><span class="heti-spacing"> </span>.</span> </p>
<p>我们可以对其进行优化，有些情况是不需要边界标记的，只有在合并时才需要脚部，而我们只会在空闲块上进行合并，所以在已分配的块上可以不需要脚部，那空闲块如何判断前一个块是否为已分配的呢？可以在自己的头部的<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>个位中用一个位来标记前一个块是否为空闲的，如果前一个块为已分配的，则无需关心前一个块的大小，因为不会进行合并；如果前一个块为空闲的，则前一个块自己就有脚部，说明了前一个块的大小，则可以顺利进行合并操作<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>即<span><span class="heti-spacing"> </span>,</span> <strong>已分配块可以不用脚部</strong>.  </p>
<h4 id="_24"><strong>实现隐式空闲链表</strong><a class="headerlink" href="#_24" title="Permanent link">¶</a></h4>
<h5 id="_25"><strong>通用分配器设计</strong><a class="headerlink" href="#_25" title="Permanent link">¶</a></h5>
<p><img alt="20220905144645" src="https://s2.loli.net/2022/09/05/kyMpzXa2g3bnsEB.png"/></p>
<ul>
<li><code>mem_init</code>函数将对于堆来说可用的虚拟内存模型化为一个大的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>双字对齐的字节数组<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>在<code>mem_heap</code>和<code>mem_brk</code>之间的字节表示已分配的虚拟内存<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>不包括<code>mem_brk</code><span class="heti-skip"><span class="heti-spacing"> </span>).<span class="heti-spacing"> </span></span><code>mem_brk</code>之后的字节表示未分配的虚拟内存<span><span class="heti-spacing"> </span>.</span> </li>
<li><code>mem_sbrk</code>移动<code>mem_brk</code>指针来调整堆内存<span><span class="heti-spacing"> </span>.</span> </li>
<li>
<p>我们还引用了另一个源文件中的函数<span><span class="heti-spacing"> </span>:</span> </p>
<p></p><div class="highlight"><pre><span></span><code><a href="#__codelineno-5-1" id="__codelineno-5-1" name="__codelineno-5-1"></a><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">mm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<a href="#__codelineno-5-2" id="__codelineno-5-2" name="__codelineno-5-2"></a><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">mm_malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<a href="#__codelineno-5-3" id="__codelineno-5-3" name="__codelineno-5-3"></a><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mm_free</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></div>
其中<code>mm_malloc</code>和<code>mm_free</code>函数与它们对应的系统函数有相同的接口和语义.<br/>
<code>mm_init</code>初始化分配器, 成功就返回 0 否则 -1. 第一个字是双字边界对齐的不使用的填充字. 然后是一个 8 字节的已分配块(也叫<strong>序言块<span><span class="heti-spacing"> </span>(prologue block)</span></strong><span>),<span class="heti-spacing"> </span></span>只包括头部和尾部<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>且永不释放<span><span class="heti-spacing"> </span>.</span><br/>
序言块后紧跟的是 0 或者多个调用创建的普通块. 最后是以一个特殊的<strong>结尾块<span><span class="heti-spacing"> </span>(epilogue block)</span></strong> 结束<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这个块大小为<span class="heti-skip"><span class="heti-spacing"> </span>0,<span class="heti-spacing"> </span></span>只由一个头部组成<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>序言块和结尾块是一种消除合并时边界条件的技巧<span><span class="heti-spacing"> </span>.</span><br/>
一个<code>heap_listp</code>指向序言块. (或者序言块的下一个块)
</li>
</ul>
<p><img alt="" src="https://pic2.zhimg.com/80/v2-620a104a2d7a0f6183b3cfc9418e0f41_1440w.jpg"/></p>
<h5 id="_26"><strong>操作空闲链表的基本常数和宏</strong><a class="headerlink" href="#_26" title="Permanent link">¶</a></h5>
<p><img alt="" src="https://pic1.zhimg.com/80/v2-8963955040740a22c3f06cbdd0395c5c_1440w.jpg"/></p>
<ul>
<li><code>PACK</code>将大小和已分配位结合并返回一个值<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>可存放到头部或者尾部<span><span class="heti-spacing"> </span>.</span> </li>
<li><code>GET</code>和<code>PUT</code>表示在地址<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>处读写一个字<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>注意这里需要强制类型转换<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>否则<span class="heti-skip"><span class="heti-spacing"> </span>void *<span class="heti-spacing"> </span></span>无法间接引用<span><span class="heti-spacing"> </span>.</span> </li>
<li><code>GET_SIZE</code>和<code>GET_ALLOC</code>表示从地址<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>处获得块大小和是否分配<span><span class="heti-spacing"> </span>.</span> </li>
<li><code>HDRP</code>和<code>FTRP</code>是输入<span class="heti-skip"><span class="heti-spacing"> </span>(bp)<span class="heti-spacing"> </span></span>指向<strong>第一个有效载荷字节</strong>的块指针<span class="heti-skip"><span class="heti-spacing"> </span>(Block Pointer),<span class="heti-spacing"> </span></span>用来获得块头部和脚部<span><span class="heti-spacing"> </span>.</span> </li>
<li><code>NEXT_BLKP</code>和<code>PREV_BLKP</code>用来获得下一个和前一个块的块指针<span><span class="heti-spacing"> </span>(bp).</span> </li>
</ul>
<h5 id="_27"><strong>创建初始空闲链表</strong><a class="headerlink" href="#_27" title="Permanent link">¶</a></h5>
<p><img alt="" src="https://pic2.zhimg.com/80/v2-9c08fff7e269d435fec557ab090f3439_1440w.jpg"/></p>
<p>首先，最小的隐式空闲链表需要包含一个字用于对齐，以及两个字的序言块和一个字的结尾块，所以首先使用<code>mem_sbrk</code>申请<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>个字的堆内存<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>然后根据要求填充对应的内容，然后让<code>heap_listp</code>指向序言块脚部的起始地址。初始完后，由于是空的堆内存，所以需要调用<code>extend_heap</code>函数来申请<code>CHUNKSIZE</code>字节<span><span class="heti-spacing"> </span>.</span><br/>
<img alt="" src="https://pic1.zhimg.com/80/v2-b8b630e2b8e7fd41cc91206e7b0cef14_1440w.jpg"/> </p>
<p><code>extend_heap</code>函数会在两种情况下被调用<span class="heti-skip"><span class="heti-spacing"> </span>:<span class="heti-spacing"> </span></span>堆被初始化时<span class="heti-skip"><span class="heti-spacing"> </span>;<span class="heti-spacing"> </span></span><code>mm_malloc</code>不能找到一个合适的匹配块时<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>为了保持对齐将<span class="heti-skip"><span class="heti-spacing"> </span>size<span class="heti-spacing"> </span></span>大小向上舍入为最接近<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>字的倍数<span><span class="heti-spacing"> </span>.</span><br/>
注意：在第 8 行申请 size 个字节后，bp 指向的是结尾块的下一个字(因为<code>mem_brk</code>不放元素)，所以在第 12 行设置空闲块头部时，根据<code>PUT</code>定义，可知这里新申请的空闲块覆盖了之前的结尾块，将其作为了自己的头部字，然后在设置脚部时，留下了一个字用来作为新的结尾块.  </p>
<p>最后尝试合并前面的空闲块<span><span class="heti-spacing"> </span>.</span> </p>
<h5 id="_28"><strong>释放和合并块</strong><a class="headerlink" href="#_28" title="Permanent link">¶</a></h5>
<p><img alt="" src="https://pic3.zhimg.com/80/v2-f209ccb5a2b9ec6d4e161da6593699c6_1440w.jpg"/></p>
<p>我们这里可以发现<span class="heti-skip"><span class="heti-spacing"> </span>:<span class="heti-spacing"> </span></span>我们将序言块和结尾块都标记为已分配<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>可以帮助我们处理边界情况<span><span class="heti-spacing"> </span>.</span> </p>
<h5 id="_29"><strong>分配块</strong><a class="headerlink" href="#_29" title="Permanent link">¶</a></h5>
<p><img alt="" src="https://pic2.zhimg.com/80/v2-70914d8355ff49f3e3b26fba7fd58299_1440w.jpg"/></p>
<p>首先字节数<span class="heti-skip"><span class="heti-spacing"> </span>size<span class="heti-spacing"> </span></span>传进来后，会现在第<span class="heti-skip"><span class="heti-spacing"> </span>12<span class="heti-spacing"> </span></span>行到<span class="heti-skip"><span class="heti-spacing"> </span>14<span class="heti-spacing"> </span></span>行判断是否满足对齐要求，然后得到满足对齐要求的字节数<span><span class="heti-spacing"> </span>asize</span>。然后尝试寻找合适的空闲块进行分配，如果没有找到合适的空闲块，就需要向内核再申请堆内存空间，再尝试分配<span><span class="heti-spacing"> </span>.</span> </p>
<h4 id="_30"><strong>显式空闲链表</strong><a class="headerlink" href="#_30" title="Permanent link">¶</a></h4>
<p>堆可以组织成一个双向空闲链表<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>每个空闲块里都包含一个<span class="heti-skip"><span class="heti-spacing"> </span>pred(<span class="heti-spacing"> </span></span>前驱<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>succ(<span class="heti-spacing"> </span></span>后继<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>指针<span><span class="heti-spacing"> </span>.</span><br/>
<img alt="" src="https://pic4.zhimg.com/80/v2-f7275609183f580aa2619b7904204da7_1440w.jpg"/></p>
<p>这样可以使得首次适配的分配时间从块总数的线性时间减少到空闲块数量的线性时间<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>不过释放一个块的时间是取决于排序策略<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><strong>后进先出<span><span class="heti-spacing"> </span>(LIFO)</span></strong><span>:<span class="heti-spacing"> </span></span>将新释放的块放在链表开始处<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这样释放一个块可以在常数时间完成<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>如果使用边界标记那么合并也是常数时间<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>当我们使用首次适配的放置策略时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>分配器会最先检查使用过的块<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>地址顺序</strong><span>:<span class="heti-spacing"> </span></span>链表每个块的地址都小于后继的地址<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这种情况下释放一个块需要线性时间来搜索定位合适的前驱<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>但可以有更高的内存利用率<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<h4 id="_31"><strong>分离的空闲链表</strong><a class="headerlink" href="#_31" title="Permanent link">¶</a></h4>
<p><strong>分离存储<span><span class="heti-spacing"> </span>(segregated storage)</span></strong> 维护多个空闲链表<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>其中每个链表中的块有大致相等的大小<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>一般思路是将所有可能的块大小划分为等价类<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>也叫<strong>大小类<span><span class="heti-spacing"> </span>(size class)</span></strong><span>,<span class="heti-spacing"> </span></span>比如可以根据<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>的幂次来划分块大小<span><span class="heti-spacing"> </span>. <span class="arithmatex">\(\{1\}, \{2\}, \{3,4\}, \ldots, \{5,6,7, 8\}\)</span></span><br/>
分配器维护一个空闲链表数组, 每个大小类一个空闲链表, 按照大小升序排列. 当分配器需要一个大小为 n 的块时, 就搜索相应的空闲链表. 如果不能找到合适的块对应就搜索下一个链表.  </p>
<h5 id="_32"><strong>简单分离存储</strong><a class="headerlink" href="#_32" title="Permanent link">¶</a></h5>
<p>每个大小类的空闲链表包含大小相等的块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>每个块的大小就是这个大小类中最大元素的大小<span><span class="heti-spacing"> </span>.</span> <br/>
为了分配一个给定大小的块, 我们会检查相应的空闲链表. 如果链表非空, 我们简单地分配其中第一块的全部. 空闲块是不会分割以满足分配请求的. 如果链表为空, 分配器就向操作系统请求一个固定大小的额外内存片(通常是页大小的整数倍), 将这个片分成大小相等的块, 并将这些块连接起来形成新的空闲链表. 要释放一个块, 分配器只要简单地将这个块插入到相应的空闲链表的前部.  </p>
<ul>
<li><strong>优点</strong><span>:<span class="heti-spacing"> </span></span>分配和释放块都是常数时间，不分割，不合并，已分配块不需要头部和脚部，空闲链表只需是单向的，因此最小块为单字大小<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>缺点</strong><span>:<span class="heti-spacing"> </span></span>由于使用分割和合并，所以会有大量的内部和外部碎片<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<h5 id="_33"><strong>分离适配</strong><a class="headerlink" href="#_33" title="Permanent link">¶</a></h5>
<p>分配器维护一个空闲链表的数组<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>每个空闲链表是和一个大小类相关联的<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>并被组织成某种类型的显式或隐式链表<span><span class="heti-spacing"> </span>.</span><br/>
分配块时，确定请求的大小类，对适当的空闲链表做首次适配，如果找到合适的块，可以分割它，将剩余的部分插入适当的空闲链表中；如果没找到合适的块，查找更大的大小类的空闲链表。如果没有合适的块，就向内核请求额外的堆内存，从这堆内存中分割出合适的块，然后将剩余部分放到合适的大小类中。每释放一个块时，就进行合并，并将其放到合适的大小类中.  </p>
<p>如<span class="heti-skip"><span class="heti-spacing"> </span>GNU malloc<span class="heti-spacing"> </span></span>包就是采用这种方法<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这种方法既快、利用率也高<span><span class="heti-spacing"> </span>.</span> </p>
<h5 id="_34"><strong>伙伴系统</strong><a class="headerlink" href="#_34" title="Permanent link">¶</a></h5>
<p><strong>伙伴系统<span><span class="heti-spacing"> </span>(buddy system)</span></strong> 是分离适配的一种特例<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>其中每个大小类都是<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>的幂<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>基本思想是假设堆的大小是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(2^m\)</span><span class="heti-spacing"> </span></span>个字<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>我们为每个块大小<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(2^k\)</span><span class="heti-spacing"> </span></span>维护一个分离空闲链表<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>请求块大小向上舍入到最接近<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>的幂<span><span class="heti-spacing"> </span>.</span><br/>
为了分配一个大小为 <span class="arithmatex">\(2^k\)</span> 的块, 我们找到第一个可用的 <span class="arithmatex">\(2^j, k&lt;=j&lt;=m\)</span> 的块. 如果 <span class="arithmatex">\(j=k\)</span> 那么分配完成, 否则我们递归地二分这个块直到 <span class="arithmatex">\(j=k\)</span>. 当我们进行这样的分割时, 每个剩下的半块(也叫<strong>伙伴</strong><span>)<span class="heti-spacing"> </span></span>被放置在相应的空闲链表中<span><span class="heti-spacing"> </span>.</span> </p>
<p>一个关键事实是<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>给定地址和块的大小<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>很容易计算出他伙伴的地址<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(xxx\ldots x00000\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(xxx\ldots x10000\)</span><span class="heti-spacing"> </span></span>互为伙伴<span><span class="heti-spacing"> </span>.</span> <strong>一个块的地址和它的伙伴的地址只有一位不相同</strong>.  </p>
<h3 id="_35"><strong>垃圾收集</strong><a class="headerlink" href="#_35" title="Permanent link">¶</a></h3>
<p><strong>垃圾收集器<span><span class="heti-spacing"> </span>(garbage collector)</span></strong> 是一种动态内存分配器<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>自动释放程序不再需要的已分配块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>这些块称为<strong>垃圾</strong>.  </p>
<p>垃圾处理器将内存看作一张<strong>有向可达图<span><span class="heti-spacing"> </span>(reachability graph)</span></strong>.  </p>
<ul>
<li>每个<strong>堆节点</strong>对应堆中的一个已分配块<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>有向边</strong> <span><span class="arithmatex">\(p\rightarrow q\)</span><span class="heti-spacing"> </span></span>意味着块<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>中某个位置指向块<span class="heti-skip"><span class="heti-spacing"> </span>q<span class="heti-spacing"> </span></span>中某个位置<span><span class="heti-spacing"> </span>.</span> </li>
<li><strong>根节点</strong>对应一种不在堆中的位置<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>包含指向堆中的指针<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>如寄存器的变量<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>虚拟内存中读写区域的全局变量等<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<p>当存在一条从任意根节点出发到达<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>的有向路径时<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>我们说<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>是<strong>可达的</strong><span>.<span class="heti-spacing"> </span></span>不可达节点对应于垃圾<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>不能被再次应用和使用<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>垃圾处理器就是维护可达图的某种表示<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>并通过释放不可达节点并把它们返回给空闲链表来定期回收它们<span><span class="heti-spacing"> </span>.</span><br/>
<img alt="" src="https://pic1.zhimg.com/80/v2-a1fe18ea70d3fe4582269eca0ba48440_1440w.jpg"/></p>
<p>对于像<span class="heti-skip"><span class="heti-spacing"> </span>ML<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>Java<span class="heti-spacing"> </span></span>语言，其对指针创建和使用有严格的要求，由此来构建十分精确的可达图，所以能回收所有垃圾<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>而对于像<span class="heti-skip"><span class="heti-spacing"> </span>C<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>C++<span class="heti-spacing"> </span></span>这样的语言，垃圾收集器无法维护十分精确的可达图，只能正确地标记所有可达节点，而有一些不可达节点会被错误地标记为可达的，所以会遗留部分垃圾，这种垃圾收集器称为<strong>保守的垃圾收集器<span><span class="heti-spacing"> </span>(Conservative Garbage Collector)</span></strong>.   </p>
<div class="admonition note">
<p class="admonition-title">在<span class="heti-skip"><span class="heti-spacing"> </span>C<span class="heti-spacing"> </span></span>中使用垃圾收集器</p>
<p>将其集成到<code>malloc</code>函数中<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>当引用调用<code>malloc</code>函数来分配块时，如果无法找到合适的空闲块，就会调用垃圾收集器来识别出所有垃圾，并调用<code>free</code>函数来进行释放。</p>
</div>
<h4 id="mark-sweep"><strong><span>Mark &amp; Sweep<span class="heti-spacing"> </span></span>垃圾收集器</strong><a class="headerlink" href="#mark-sweep" title="Permanent link">¶</a></h4>
<p><strong><span>Mark&amp;Sweep<span class="heti-spacing"> </span></span>垃圾收集器</strong>由两个阶段组成<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><strong>标记阶段</strong><span>:<span class="heti-spacing"> </span></span>标记出根节点的所有已达和已分配的后继  </li>
<li><strong>清理阶段</strong><span>:<span class="heti-spacing"> </span></span>释放每个未被标记的已分配块<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>块头部中空闲的低位中的一位表示这个块是否被标记了<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<p>我们将使用下面函数<span><span class="heti-spacing"> </span>:</span> </p>
<ul>
<li><strong><code>ptr isPtr(ptr p)</code></strong><span>:<span class="heti-spacing"> </span></span>如果<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>指向一个已分配块中的某个字<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>那么就返回一个指向这个块的起始位置的指针<span class="heti-skip"><span class="heti-spacing"> </span>p,<span class="heti-spacing"> </span></span>否则返回<span><span class="heti-spacing"> </span>NULL.</span> </li>
<li><strong><code>int blockMarked(ptr b)</code></strong><span>:<span class="heti-spacing"> </span></span>如果块<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>已标记<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>返回<span><span class="heti-spacing"> </span>true.</span> </li>
<li><strong><code>blockAllocated(ptr b)</code></strong><span>:<span class="heti-spacing"> </span></span>如果块<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>已分配<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>返回<span><span class="heti-spacing"> </span>true.</span> </li>
<li><strong><code>void markBlock(ptr b)</code></strong><span>:<span class="heti-spacing"> </span></span>标记块<span><span class="heti-spacing"> </span>b</span> </li>
<li><strong><code>int length(ptr b)</code></strong><span>:<span class="heti-spacing"> </span></span>返回块<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>以字为单位的长度<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>不含头部<span><span class="heti-spacing"> </span>)</span> </li>
<li><strong><code>void unmarkBlock(ptr b)</code></strong><span>:<span class="heti-spacing"> </span></span>将块<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>的状态由已标记改为未标记   </li>
<li><strong><code>ptr nextBlock(ptr b)</code></strong><span>:<span class="heti-spacing"> </span></span>返回堆中块<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>的后继  </li>
</ul>
<p><img alt="" src="https://pic3.zhimg.com/80/v2-f2e91d45ced4c95bfbe9a9e877f6188e_1440w.jpg"/></p>
<p><img alt="" src="https://pic4.zhimg.com/80/v2-50dfad7f602ae1594864029403860d5b_1440w.jpg"/></p>
<h4 id="c-mark-sweep"><strong><span>C<span class="heti-spacing"> </span></span>程序保守的<span><span class="heti-spacing"> </span>Mark &amp; Sweep</span></strong><a class="headerlink" href="#c-mark-sweep" title="Permanent link">¶</a></h4>
<p><span>C<span class="heti-spacing"> </span></span>程序想要使用<span class="heti-skip"><span class="heti-spacing"> </span>Mark&amp;Sweep<span class="heti-spacing"> </span></span>垃圾收集器，在实现<code>isPtr</code>函数时具有两个困难：</p>
<ul>
<li>进入<code>isPtr</code>函数时，首先需要判断输入的<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>是否为指针，只有<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>为指针，才判断<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>是否指向某个已分配块的有效载荷<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>但是在<span class="heti-skip"><span class="heti-spacing"> </span>C<span class="heti-spacing"> </span></span>语言不会用类型信息来标记内存位置，比如<span class="heti-skip"><span class="heti-spacing"> </span>int<span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span>float<span class="heti-spacing"> </span></span>这些标量就可能被伪装成指针，比如<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>对应的是一个<span class="heti-skip"><span class="heti-spacing"> </span>int<span class="heti-spacing"> </span></span>类型数据，但是<span class="heti-skip"><span class="heti-spacing"> </span>C<span class="heti-spacing"> </span></span>误以为是指针，而将该数据作为指针又正好指向某个不可达的已分配块中，则分配器会误以为该分配块时可达的，造成无法对该垃圾进行回收<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这也是<span class="heti-skip"><span class="heti-spacing"> </span>C<span class="heti-spacing"> </span></span>程序的<span class="heti-skip"><span class="heti-spacing"> </span>Mark&amp;Sweep<span class="heti-spacing"> </span></span>垃圾收集器必须是保守的原因<span><span class="heti-spacing"> </span>.</span> </li>
<li>当判断<span class="heti-skip"><span class="heti-spacing"> </span>p<span class="heti-spacing"> </span></span>为指针时，如何确定它所在块的头部<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>这里可以将已分配的块组织成平衡二叉树的形式，如下所示，保证左子树所有的块都在较小的地址处，右子树所有的块都在较大的地址处<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>此时输入一个指针<span><span class="heti-spacing"> </span>p</span>，从该树的根节点开始，根据块头部的块大小字段来判断指针是否指向该块，如果不是，根据地址大小可跳转到左子树或右子树进行查找<span><span class="heti-spacing"> </span>.</span> </li>
</ul>
<h2 id="c"><strong><span>C<span class="heti-spacing"> </span></span>程序中常见与内存有关的错误</strong><a class="headerlink" href="#c" title="Permanent link">¶</a></h2>
<h3 id="_36"><strong>间接引用坏指针</strong><a class="headerlink" href="#_36" title="Permanent link">¶</a></h3>
<p>对于每个进程内核都维护了一个<code>vm_area_struct</code>数据结构，来将虚拟内存划分成不同的段，这也造成虚拟内存可能是不连续的，如果我们尝试对不处于任何段的虚拟内存进行引用时，内核就会发出段异常终止程序<span class="heti-skip"><span class="heti-spacing"> </span>.<span class="heti-spacing"> </span></span>其次，不同段限制了不同页的读写权限，如果我们尝试对只读虚拟页进行写操作时，内核就会发出保护异常终止程序<span><span class="heti-spacing"> </span>.</span> <br/>
如<br/>
<code>scanf("%d, val");</code>
如果 val 对应虚拟内存某个合法的读写区域, 我们就覆盖了这块内存.  </p>
<h3 id="_37"><strong>读未初始化的内存</strong><a class="headerlink" href="#_37" title="Permanent link">¶</a></h3>
<p>我们定义的未初始化的全局变量处于<code>.bss</code>段中，该段会与匿名文件进行关联，使得未初始化的全局变量都为<span><span class="heti-spacing"> </span>0</span>。但是使用<code>malloc</code>分配堆内存时，只是简单的修改了<span class="heti-skip"><span class="heti-spacing"> </span>brk<span class="heti-spacing"> </span></span>指针，并不会对已分配的块进行任何初始化，所以要对动态内存分配得到的堆内存进行初始化<span class="heti-skip"><span class="heti-spacing"> </span>.(<span class="heti-spacing"> </span></span><code>calloc</code>函数会进行初始化<span><span class="heti-spacing"> </span>)</span></p>
<h3 id="_38"><strong>允许栈缓冲区溢出</strong><a class="headerlink" href="#_38" title="Permanent link">¶</a></h3>
<p>不检查输入串的大小就写入栈中的目标缓冲区<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>就会由<strong>缓冲区溢出错误<span><span class="heti-spacing"> </span>(buffer overflow bug)</span></strong>.<br/>
如<br/>
</p><div class="highlight"><pre><span></span><code><a href="#__codelineno-6-1" id="__codelineno-6-1" name="__codelineno-6-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">bufferoverflow</span><span class="p">()</span>
<a href="#__codelineno-6-2" id="__codelineno-6-2" name="__codelineno-6-2"></a><span class="p">{</span>
<a href="#__codelineno-6-3" id="__codelineno-6-3" name="__codelineno-6-3"></a><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<a href="#__codelineno-6-4" id="__codelineno-6-4" name="__codelineno-6-4"></a>
<a href="#__codelineno-6-5" id="__codelineno-6-5" name="__codelineno-6-5"></a><span class="w">    </span><span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<a href="#__codelineno-6-6" id="__codelineno-6-6" name="__codelineno-6-6"></a><span class="w">    </span><span class="k">return</span><span class="p">;</span>
<a href="#__codelineno-6-7" id="__codelineno-6-7" name="__codelineno-6-7"></a><span class="p">}</span>
</code></pre></div>
我们应该使用<code>fgets</code>函数, 限制输入串的大小.  
<h3 id="_39"><strong>假设指针和他们指向的对象是相同大小</strong><a class="headerlink" href="#_39" title="Permanent link">¶</a></h3>
<p></p><div class="highlight"><pre><span></span><code><a href="#__codelineno-7-1" id="__codelineno-7-1" name="__codelineno-7-1"></a><span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="nf">makeArray1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
<a href="#__codelineno-7-2" id="__codelineno-7-2" name="__codelineno-7-2"></a><span class="p">{</span>
<a href="#__codelineno-7-3" id="__codelineno-7-3" name="__codelineno-7-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<a href="#__codelineno-7-4" id="__codelineno-7-4" name="__codelineno-7-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<a href="#__codelineno-7-5" id="__codelineno-7-5" name="__codelineno-7-5"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a href="#__codelineno-7-6" id="__codelineno-7-6" name="__codelineno-7-6"></a><span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<a href="#__codelineno-7-7" id="__codelineno-7-7" name="__codelineno-7-7"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<a href="#__codelineno-7-8" id="__codelineno-7-8" name="__codelineno-7-8"></a><span class="p">}</span>
</code></pre></div>
第四行应该是<code>sizeof(int *)</code>而不是<code>sizeof(int)</code>.  
<h3 id="_40"><strong>错位错误</strong><a class="headerlink" href="#_40" title="Permanent link">¶</a></h3>
<p></p><div class="highlight"><pre><span></span><code><a href="#__codelineno-8-1" id="__codelineno-8-1" name="__codelineno-8-1"></a><span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="nf">makeArray1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
<a href="#__codelineno-8-2" id="__codelineno-8-2" name="__codelineno-8-2"></a><span class="p">{</span>
<a href="#__codelineno-8-3" id="__codelineno-8-3" name="__codelineno-8-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<a href="#__codelineno-8-4" id="__codelineno-8-4" name="__codelineno-8-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">));</span>
<a href="#__codelineno-8-5" id="__codelineno-8-5" name="__codelineno-8-5"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a href="#__codelineno-8-6" id="__codelineno-8-6" name="__codelineno-8-6"></a><span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<a href="#__codelineno-8-7" id="__codelineno-8-7" name="__codelineno-8-7"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<a href="#__codelineno-8-8" id="__codelineno-8-8" name="__codelineno-8-8"></a><span class="p">}</span>
</code></pre></div>
第五行多初始化了一元素. (0~n 是 n+1 个元素, 而不是 n 个)   
<h3 id="_41"><strong>引用指针而不是它指向的对象</strong><a class="headerlink" href="#_41" title="Permanent link">¶</a></h3>
<p></p><div class="highlight"><pre><span></span><code><a href="#__codelineno-9-1" id="__codelineno-9-1" name="__codelineno-9-1"></a><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="nf">binheapDelete</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="n">binheap</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p">)</span>
<a href="#__codelineno-9-2" id="__codelineno-9-2" name="__codelineno-9-2"></a><span class="p">{</span>
<a href="#__codelineno-9-3" id="__codelineno-9-3" name="__codelineno-9-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">packet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">binheap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<a href="#__codelineno-9-4" id="__codelineno-9-4" name="__codelineno-9-4"></a>
<a href="#__codelineno-9-5" id="__codelineno-9-5" name="__codelineno-9-5"></a><span class="w">    </span><span class="n">binheap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">binheap</span><span class="p">[</span><span class="o">*</span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<a href="#__codelineno-9-6" id="__codelineno-9-6" name="__codelineno-9-6"></a><span class="w">    </span><span class="o">*</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
<a href="#__codelineno-9-7" id="__codelineno-9-7" name="__codelineno-9-7"></a><span class="w">    </span><span class="n">heapify</span><span class="p">(</span><span class="n">binheap</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<a href="#__codelineno-9-8" id="__codelineno-9-8" name="__codelineno-9-8"></a><span class="w">    </span><span class="k">return</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
<a href="#__codelineno-9-9" id="__codelineno-9-9" name="__codelineno-9-9"></a><span class="p">}</span>
</code></pre></div>
第六行, 一元运算符<code>--</code>和<code>*</code>优先级相同, 从右往左结合. 因此第六行实际减少的是指针的值, 而不是它指向的整数的值.  
<h3 id="_42"><strong>误解指针运算</strong><a class="headerlink" href="#_42" title="Permanent link">¶</a></h3>
<p></p><div class="highlight"><pre><span></span><code><a href="#__codelineno-10-1" id="__codelineno-10-1" name="__codelineno-10-1"></a><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="nf">search</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<a href="#__codelineno-10-2" id="__codelineno-10-2" name="__codelineno-10-2"></a><span class="p">{</span>
<a href="#__codelineno-10-3" id="__codelineno-10-3" name="__codelineno-10-3"></a><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<a href="#__codelineno-10-4" id="__codelineno-10-4" name="__codelineno-10-4"></a><span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<a href="#__codelineno-10-5" id="__codelineno-10-5" name="__codelineno-10-5"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<a href="#__codelineno-10-6" id="__codelineno-10-6" name="__codelineno-10-6"></a><span class="p">}</span>
</code></pre></div>
指针的算术操作是以它们指向的对象的大小为单位来进行, 而不是字节. <br/>
第四行应为<code>p++</code>.   
<h3 id="_43"><strong>引用不存在的变量</strong><a class="headerlink" href="#_43" title="Permanent link">¶</a></h3>
<p></p><div class="highlight"><pre><span></span><code><a href="#__codelineno-11-1" id="__codelineno-11-1" name="__codelineno-11-1"></a><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="nf">stackref</span><span class="p">()</span>
<a href="#__codelineno-11-2" id="__codelineno-11-2" name="__codelineno-11-2"></a><span class="p">{</span>
<a href="#__codelineno-11-3" id="__codelineno-11-3" name="__codelineno-11-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<a href="#__codelineno-11-4" id="__codelineno-11-4" name="__codelineno-11-4"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">;</span>
<a href="#__codelineno-11-5" id="__codelineno-11-5" name="__codelineno-11-5"></a><span class="p">}</span>
</code></pre></div>
这里返回的指针, 尽管仍然指向一个合法的内存地址, 但已经不再是一个合法的变量了.(局部变量在栈帧中, 函数结束栈毁灭了)    
<h3 id="_44"><strong>引用空闲堆块中的数据</strong><a class="headerlink" href="#_44" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><span></span><code><a href="#__codelineno-12-1" id="__codelineno-12-1" name="__codelineno-12-1"></a><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="nf">heapref</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
<a href="#__codelineno-12-2" id="__codelineno-12-2" name="__codelineno-12-2"></a><span class="p">{</span>
<a href="#__codelineno-12-3" id="__codelineno-12-3" name="__codelineno-12-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<a href="#__codelineno-12-4" id="__codelineno-12-4" name="__codelineno-12-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">;</span>
<a href="#__codelineno-12-5" id="__codelineno-12-5" name="__codelineno-12-5"></a><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<a href="#__codelineno-12-6" id="__codelineno-12-6" name="__codelineno-12-6"></a><span class="w">    </span><span class="p">...</span>
<a href="#__codelineno-12-7" id="__codelineno-12-7" name="__codelineno-12-7"></a><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<a href="#__codelineno-12-8" id="__codelineno-12-8" name="__codelineno-12-8"></a>
<a href="#__codelineno-12-9" id="__codelineno-12-9" name="__codelineno-12-9"></a><span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<a href="#__codelineno-12-10" id="__codelineno-12-10" name="__codelineno-12-10"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a href="#__codelineno-12-11" id="__codelineno-12-11" name="__codelineno-12-11"></a><span class="w">        </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<a href="#__codelineno-12-12" id="__codelineno-12-12" name="__codelineno-12-12"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<a href="#__codelineno-12-13" id="__codelineno-12-13" name="__codelineno-12-13"></a><span class="p">}</span>
</code></pre></div>
<h3 id="_45"><strong>引起内存泄漏</strong><a class="headerlink" href="#_45" title="Permanent link">¶</a></h3>
<p>程序员忘记释放已分配块<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>而在堆里创建了垃圾<span class="heti-skip"><span class="heti-spacing"> </span>,<span class="heti-spacing"> </span></span>会逐渐占用虚拟地址空间的内存<span><span class="heti-spacing"> </span>.</span><br/>
</p><div class="highlight"><pre><span></span><code><a href="#__codelineno-13-1" id="__codelineno-13-1" name="__codelineno-13-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">leak</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<a href="#__codelineno-13-2" id="__codelineno-13-2" name="__codelineno-13-2"></a><span class="p">{</span>
<a href="#__codelineno-13-3" id="__codelineno-13-3" name="__codelineno-13-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<a href="#__codelineno-13-4" id="__codelineno-13-4" name="__codelineno-13-4"></a><span class="w">    </span><span class="k">return</span><span class="p">;</span>
<a href="#__codelineno-13-5" id="__codelineno-13-5" name="__codelineno-13-5"></a><span class="p">}</span>
</code></pre></div>
<aside class="md-source-file">
<span class="md-source-file__fact">
<span class="md-icon" title="最后更新">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"></path></svg>
</span>
<span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="2022年9月5日 23:38:05 CST">2022年9月5日 23:38:05</span>
</span>
<span class="md-source-file__fact">
<span class="md-icon" title="创建日期">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"></path></svg>
</span>
<span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="2022年9月5日 23:38:05 CST">2022年9月5日 23:38:05</span>
</span>
</aside>
<!-- Giscus -->
<h2 id="__comments">评论</h2>
<!-- 这里改成你的Giscus代码 -->
<script async="" crossorigin="anonymous" data-category="General" data-category-id="DIC_kwDOHtZjDs4CQZ7Z" data-emit-metadata="0" data-input-position="top" data-lang="zh-CN" data-mapping="pathname" data-reactions-enabled="1" data-repo="HobbitQia/notebook" data-repo-id="R_kgDOHtZjDg" data-strict="0" data-theme="light" src="https://giscus.app/client.js">
</script>
<!-- Reload on palette change -->
<script>
    var palette = __md_get("__palette")
    if (palette && typeof palette.color === "object")
        if (palette.color.scheme === "slate") {
            var giscus = document.querySelector("script[src*=giscus]")
            giscus.setAttribute("data-theme", "dark")
        }

    /* Register event handlers after documented loaded */
    document.addEventListener("DOMContentLoaded", function () {
        var ref = document.querySelector("[data-md-component=palette]")
        ref.addEventListener("change", function () {
            var palette = __md_get("__palette")
            if (palette && typeof palette.color === "object") {
                var theme = palette.color.scheme === "slate" ? "dark" : "light"

                /* Instruct Giscus to change theme */
                var frame = document.querySelector(".giscus-frame")
                frame.contentWindow.postMessage(
                    { giscus: { setConfig: { theme } } },
                    "https://giscus.app"
                )
            }
        })
    })
</script>
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
<button class="md-top md-icon" data-md-component="top" hidden="" type="button">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"></path></svg>
  回到页面顶部
</button>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
<div class="md-copyright__highlight">
      Copyright © 2022 <a href="https://github.com/HobbitQia" rel="noopener" target="_blank">HobbitQia</a>
</div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
<div class="md-social">
<a class="md-social__link" href="https://github.com/HobbitQia/" rel="noopener" target="_blank" title="github.com">
<svg viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"></path></svg>
</a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../..", "features": ["content.code.annotate", "navigation.tracking", "navigation.tabs", "navigation.indexes", "navigation.top"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
<script src="../../assets/javascripts/bundle.f55a23d4.min.js"></script>
<script src="../../js/baidu-tongji.js"></script>
<script src="https://gcore.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
<script src="../../js/katex.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>